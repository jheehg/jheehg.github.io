{
    "version": "https://jsonfeed.org/version/1",
    "title": "jheehg blog",
    "home_page_url": "https://jheehg.github.io/",
    "feed_url": "https://jheehg.github.io/feed.json",
    "description": "jheehg blog",
    "icon": "https://jheehg.github.io/apple-touch-icon.png",
    "favicon": "https://jheehg.github.io/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "https://jheehg.github.io/2023/04/18/infinite-scroll-using-graphql",
            "title": "간단한 무한 스크롤 만들어보기 with graphQL",
            "summary": "간단한 무한 스크롤 만들어보기 with graphQL",
            "content_text": "간단한 설명  스크롤이 가장 밑에 닿으면 fetch 가 새로운 파라미터와 함께 재호출된다.  더이상 결과가 존재하지 않으면 no more data 텍스트가 보여지고 fetch 는 진행하지 않는다.사용한 소스:: API (thecatapi)https://api.thecatapi.com/v1/images/search:: 요청 파라미터`limit`: 한번에 불러오는 이미지 수 (1 ~ 100)`page`: 요청할 페이지ServertypeDefsconst typeDefs = `#graphqltype Image {  id: ID!  height: Int!  width: Int!  url: String!}type Query {  images(limit: Int, page: Int): [Image!]!}`;resolvers  첫번째 파라미터는 리졸버 체인 상에서 부모 필드를 의미하는데 여기선 사용하지 않음.  두번째 파라미터는 Query 를 실행할때 받은 arguments 이다.import fetch from ‘node-fetch’;const resolvers = {  Query: {    async images(_, { limit, page }) {      const r = await fetch(        `https://api.thecatapi.com/v1/images/search?limit=${limit}&amp;page=${page}`      );      const json = await r.json();      return json;    },  },};서버 인스턴스 생성 및 실행import { ApolloServer } from ‘@apollo/server’;import { startStandaloneServer } from ‘@apollo/server/standalone’;const server = new ApolloServer({  typeDefs,  resolvers,});const { url } = await startStandaloneServer(server, {  listen: { port: 4000 },});console.log(`🚀  Server ready at ${url}`);ClientQueryApollo Server Explorer 에서도 쉽게 테스트가 가능해서 Query syntax 오류날 경우 참고하기 좋은 것 같다.import { gql, useQuery } from ‘@apollo/client’;const GET_IMAGES = gql`  query getImages($limit: Int, $page: Int) {    images(limit: $limit, page: $page) {      id      height      width      url    }  }`;UseQuery 호출위에서 gql 로 생성한 쿼리를 첫번째 인자로 넣고 두번째 인자로 input data 인 limit, page 를 넣어준다.  import { gql, useQuery } from ‘@apollo/client’;  const { loading, error, data, fetchMore } = useQuery(GET_IMAGES, {    variables: {      limit: 10,      page: 1,    },  });fetchMore 실행scroll 이벤트의 콜백함수로 loadMoreImages 를 사용하는데 이 안에서 currentPage 값을 참조하기 때문에 useEffect 디펜던시에 넣어줘야 업데이트된 currentPage 를 참조할 수 있다.더이상 가져올 이미지가 없으면 isLoadingMore 상태를 false 로 변경하고그렇지 않을 경우 currentPage 를 1 증가시킨다.const [isLoadingMore, setIsLoadingMore] = useState(true);const [currentPage, setCurrentPage] = useState(1);useEffect(() =&gt; {  window.addEventListener(‘scroll’, loadMoreImages);  return () =&gt; window.removeEventListener(‘scroll’, loadMoreImages);}, [currentPage]);const loadMoreImages = () =&gt; {   if (isAtTheBottom()) { // 스크롤 위치 확인     const nextPage = currentPage + 1;      fetchMore({      variables: {        limit: 10,        page: nextPage,      },   }).then(({ data }) =&gt; {      if (data?.images?.length === 0) {        setIsLoadingMore(false);      } else {        setCurrentPage(nextPage);      }   }); }};cache 설정read 함수가 실행이 계속 안되서 고생했는데 keyArgs 필드에 false 값을 줘야 한다.// utils/client.tsimport { ApolloClient, InMemoryCache } from ‘@apollo/client’;const cache = new InMemoryCache({  typePolicies: {    Query: {      fields: {        images: {          keyArgs: false,          read(existing) {            return existing &amp;&amp; existing.slice(0);          },          merge(existing, incoming) {            // Slicing is necessary because the existing data is            // immutable, and frozen in development.            const merged = existing ? existing.slice(0) : [];            return [...merged, ...incoming];          },        },      },    },  },});const client = new ApolloClient({  uri: ‘http://localhost:4000’,  cache,});export default client;💡KeyArgsIf a field accepts arguments, you can specify an array of keyArgs in the field’s FieldPolicy. This array indicates which arguments are key arguments that affect the field’s return value. Specifying this array can help reduce the amount of duplicate data in your cache.👉 Key Argument에 명시된 필드에 대해서는 중복을 제외시키는 것 같다. merge 된 데이터를 조회해야 하므로 limit, page 를 필드로 넣으면 정상적으로 캐시 데이터가 조회 되지 않는다.+ 캐시 사용 안하고 Query 를 업데이트 하는 방법 updateQuery: (previousResult, { fetchMoreResult }) =&gt; {   if (!fetchMoreResult || fetchMoreResult.images.length === 0) {     setIsLoadingMore(false);     return previousResult;   }   setCurrentPage(nextPage);   return Object.assign({}, previousResult, {     images: [       ...previousResult.images,       ...fetchMoreResult.images,     ],   }); },결과는 요거참고자료는Apollo GraphQL 와 챗지피티! 🥲",
            "content_html": "<h3 id=\"간단한-설명\">간단한 설명</h3><ul>  <li>스크롤이 가장 밑에 닿으면 fetch 가 새로운 파라미터와 함께 재호출된다.</li>  <li>더이상 결과가 존재하지 않으면 no more data 텍스트가 보여지고 fetch 는 진행하지 않는다.</li></ul><p><br /></p><h3 id=\"사용한-소스\">사용한 소스</h3><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>:: API (thecatapi)https://api.thecatapi.com/v1/images/search:: 요청 파라미터`limit`: 한번에 불러오는 이미지 수 (1 ~ 100)`page`: 요청할 페이지</code></pre></div></div><p><br /><br /></p><h2 id=\"server\">Server</h2><h4 id=\"typedefs\">typeDefs</h4><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">typeDefs</span> <span class=\"o\">=</span> <span class=\"s2\">`#graphqltype Image {  id: ID!  height: Int!  width: Int!  url: String!}type Query {  images(limit: Int, page: Int): [Image!]!}`</span><span class=\"p\">;</span></code></pre></div></div><p><br /></p><h4 id=\"resolvers\">resolvers</h4><ul>  <li>첫번째 파라미터는 리졸버 체인 상에서 부모 필드를 의미하는데 여기선 사용하지 않음.</li>  <li>두번째 파라미터는 Query 를 실행할때 받은 arguments 이다.</li></ul><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"nx\">fetch</span> <span class=\"k\">from</span> <span class=\"err\">‘</span><span class=\"nx\">node</span><span class=\"o\">-</span><span class=\"nx\">fetch</span><span class=\"err\">’</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">resolvers</span> <span class=\"o\">=</span> <span class=\"p\">{</span>  <span class=\"na\">Query</span><span class=\"p\">:</span> <span class=\"p\">{</span>    <span class=\"k\">async</span> <span class=\"nx\">images</span><span class=\"p\">(</span><span class=\"nx\">_</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">limit</span><span class=\"p\">,</span> <span class=\"nx\">page</span> <span class=\"p\">})</span> <span class=\"p\">{</span>      <span class=\"kd\">const</span> <span class=\"nx\">r</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">fetch</span><span class=\"p\">(</span>        <span class=\"s2\">`https://api.thecatapi.com/v1/images/search?limit=</span><span class=\"p\">${</span><span class=\"nx\">limit</span><span class=\"p\">}</span><span class=\"s2\">&amp;page=</span><span class=\"p\">${</span><span class=\"nx\">page</span><span class=\"p\">}</span><span class=\"s2\">`</span>      <span class=\"p\">);</span>      <span class=\"kd\">const</span> <span class=\"nx\">json</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">r</span><span class=\"p\">.</span><span class=\"nx\">json</span><span class=\"p\">();</span>      <span class=\"k\">return</span> <span class=\"nx\">json</span><span class=\"p\">;</span>    <span class=\"p\">},</span>  <span class=\"p\">},</span><span class=\"p\">};</span></code></pre></div></div><p><br /></p><h4 id=\"서버-인스턴스-생성-및-실행\">서버 인스턴스 생성 및 실행</h4><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">ApolloServer</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"err\">‘</span><span class=\"p\">@</span><span class=\"nd\">apollo</span><span class=\"sr\">/server’</span><span class=\"err\">;</span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">startStandaloneServer</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"err\">‘</span><span class=\"p\">@</span><span class=\"nd\">apollo</span><span class=\"sr\">/server/</span><span class=\"nx\">standalone</span><span class=\"err\">’</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">server</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">ApolloServer</span><span class=\"p\">({</span>  <span class=\"nx\">typeDefs</span><span class=\"p\">,</span>  <span class=\"nx\">resolvers</span><span class=\"p\">,</span><span class=\"p\">});</span><span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"nx\">url</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">startStandaloneServer</span><span class=\"p\">(</span><span class=\"nx\">server</span><span class=\"p\">,</span> <span class=\"p\">{</span>  <span class=\"na\">listen</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"na\">port</span><span class=\"p\">:</span> <span class=\"mi\">4000</span> <span class=\"p\">},</span><span class=\"p\">});</span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`🚀  Server ready at </span><span class=\"p\">${</span><span class=\"nx\">url</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">);</span></code></pre></div></div><p><br /><br /></p><h2 id=\"client\">Client</h2><h4 id=\"query\">Query</h4><p>Apollo Server Explorer 에서도 쉽게 테스트가 가능해서 Query syntax 오류날 경우 참고하기 좋은 것 같다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">gql</span><span class=\"p\">,</span> <span class=\"nx\">useQuery</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"err\">‘</span><span class=\"p\">@</span><span class=\"nd\">apollo</span><span class=\"sr\">/client’</span><span class=\"err\">;</span><span class=\"kd\">const</span> <span class=\"nx\">GET_IMAGES</span> <span class=\"o\">=</span> <span class=\"nx\">gql</span><span class=\"s2\">`  query getImages($limit: Int, $page: Int) {    images(limit: $limit, page: $page) {      id      height      width      url    }  }`</span><span class=\"p\">;</span></code></pre></div></div><p><img src=\"https://user-images.githubusercontent.com/56527636/232785357-346372ad-ab81-43b4-b6e8-c037be15dbdf.png\" alt=\"apollo-explorer\" /></p><h4 id=\"usequery-호출\">UseQuery 호출</h4><p>위에서 <code class=\"language-plaintext highlighter-rouge\">gql</code> 로 생성한 쿼리를 첫번째 인자로 넣고 두번째 인자로 input data 인 <code class=\"language-plaintext highlighter-rouge\">limit</code>, <code class=\"language-plaintext highlighter-rouge\">page</code> 를 넣어준다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">gql</span><span class=\"p\">,</span> <span class=\"nx\">useQuery</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"err\">‘</span><span class=\"p\">@</span><span class=\"nd\">apollo</span><span class=\"sr\">/client’</span><span class=\"err\">;</span>  <span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"nx\">loading</span><span class=\"p\">,</span> <span class=\"nx\">error</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">fetchMore</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">useQuery</span><span class=\"p\">(</span><span class=\"nx\">GET_IMAGES</span><span class=\"p\">,</span> <span class=\"p\">{</span>    <span class=\"na\">variables</span><span class=\"p\">:</span> <span class=\"p\">{</span>      <span class=\"na\">limit</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>      <span class=\"na\">page</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>    <span class=\"p\">},</span>  <span class=\"p\">});</span></code></pre></div></div><p><br /></p><h4 id=\"fetchmore-실행\">fetchMore 실행</h4><p>scroll 이벤트의 콜백함수로 <code class=\"language-plaintext highlighter-rouge\">loadMoreImages</code> 를 사용하는데 이 안에서 <code class=\"language-plaintext highlighter-rouge\">currentPage</code> 값을 참조하기 때문에 <code class=\"language-plaintext highlighter-rouge\">useEffect</code> 디펜던시에 넣어줘야 업데이트된 <code class=\"language-plaintext highlighter-rouge\">currentPage</code> 를 참조할 수 있다.<br />더이상 가져올 이미지가 없으면 <code class=\"language-plaintext highlighter-rouge\">isLoadingMore</code> 상태를 <strong>false</strong> 로 변경하고그렇지 않을 경우 <code class=\"language-plaintext highlighter-rouge\">currentPage</code> 를 <strong>1</strong> 증가시킨다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"p\">[</span><span class=\"nx\">isLoadingMore</span><span class=\"p\">,</span> <span class=\"nx\">setIsLoadingMore</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span><span class=\"kd\">const</span> <span class=\"p\">[</span><span class=\"nx\">currentPage</span><span class=\"p\">,</span> <span class=\"nx\">setCurrentPage</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">addEventListener</span><span class=\"p\">(</span><span class=\"err\">‘</span><span class=\"nx\">scroll</span><span class=\"err\">’</span><span class=\"p\">,</span> <span class=\"nx\">loadMoreImages</span><span class=\"p\">);</span>  <span class=\"k\">return</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">removeEventListener</span><span class=\"p\">(</span><span class=\"err\">‘</span><span class=\"nx\">scroll</span><span class=\"err\">’</span><span class=\"p\">,</span> <span class=\"nx\">loadMoreImages</span><span class=\"p\">);</span><span class=\"p\">},</span> <span class=\"p\">[</span><span class=\"nx\">currentPage</span><span class=\"p\">]);</span><span class=\"kd\">const</span> <span class=\"nx\">loadMoreImages</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>   <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">isAtTheBottom</span><span class=\"p\">())</span> <span class=\"p\">{</span> <span class=\"c1\">// 스크롤 위치 확인</span>     <span class=\"kd\">const</span> <span class=\"nx\">nextPage</span> <span class=\"o\">=</span> <span class=\"nx\">currentPage</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>      <span class=\"nx\">fetchMore</span><span class=\"p\">({</span>      <span class=\"na\">variables</span><span class=\"p\">:</span> <span class=\"p\">{</span>        <span class=\"na\">limit</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>        <span class=\"na\">page</span><span class=\"p\">:</span> <span class=\"nx\">nextPage</span><span class=\"p\">,</span>      <span class=\"p\">},</span>   <span class=\"p\">}).</span><span class=\"nx\">then</span><span class=\"p\">(({</span> <span class=\"nx\">data</span> <span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">data</span><span class=\"p\">?.</span><span class=\"nx\">images</span><span class=\"p\">?.</span><span class=\"nx\">length</span> <span class=\"o\">===</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"nx\">setIsLoadingMore</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">);</span>      <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>        <span class=\"nx\">setCurrentPage</span><span class=\"p\">(</span><span class=\"nx\">nextPage</span><span class=\"p\">);</span>      <span class=\"p\">}</span>   <span class=\"p\">});</span> <span class=\"p\">}</span><span class=\"p\">};</span></code></pre></div></div><p><br /></p><h4 id=\"cache-설정\">cache 설정</h4><p>read 함수가 실행이 계속 안되서 고생했는데 keyArgs 필드에 <code class=\"language-plaintext highlighter-rouge\">false</code> 값을 줘야 한다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// utils/client.ts</span><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">ApolloClient</span><span class=\"p\">,</span> <span class=\"nx\">InMemoryCache</span> <span class=\"p\">}</span> <span class=\"k\">from</span> <span class=\"err\">‘</span><span class=\"p\">@</span><span class=\"nd\">apollo</span><span class=\"sr\">/client’</span><span class=\"err\">;</span><span class=\"kd\">const</span> <span class=\"nx\">cache</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">InMemoryCache</span><span class=\"p\">({</span>  <span class=\"na\">typePolicies</span><span class=\"p\">:</span> <span class=\"p\">{</span>    <span class=\"na\">Query</span><span class=\"p\">:</span> <span class=\"p\">{</span>      <span class=\"na\">fields</span><span class=\"p\">:</span> <span class=\"p\">{</span>        <span class=\"na\">images</span><span class=\"p\">:</span> <span class=\"p\">{</span>          <span class=\"na\">keyArgs</span><span class=\"p\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>          <span class=\"nx\">read</span><span class=\"p\">(</span><span class=\"nx\">existing</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"k\">return</span> <span class=\"nx\">existing</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">existing</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>          <span class=\"p\">},</span>          <span class=\"nx\">merge</span><span class=\"p\">(</span><span class=\"nx\">existing</span><span class=\"p\">,</span> <span class=\"nx\">incoming</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"c1\">// Slicing is necessary because the existing data is</span>            <span class=\"c1\">// immutable, and frozen in development.</span>            <span class=\"kd\">const</span> <span class=\"nx\">merged</span> <span class=\"o\">=</span> <span class=\"nx\">existing</span> <span class=\"p\">?</span> <span class=\"nx\">existing</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"p\">[];</span>            <span class=\"k\">return</span> <span class=\"p\">[...</span><span class=\"nx\">merged</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">incoming</span><span class=\"p\">];</span>          <span class=\"p\">},</span>        <span class=\"p\">},</span>      <span class=\"p\">},</span>    <span class=\"p\">},</span>  <span class=\"p\">},</span><span class=\"p\">});</span><span class=\"kd\">const</span> <span class=\"nx\">client</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">ApolloClient</span><span class=\"p\">({</span>  <span class=\"na\">uri</span><span class=\"p\">:</span> <span class=\"err\">‘</span><span class=\"na\">http</span><span class=\"p\">:</span><span class=\"c1\">//localhost:4000’,</span>  <span class=\"nx\">cache</span><span class=\"p\">,</span><span class=\"p\">});</span><span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">client</span><span class=\"p\">;</span></code></pre></div></div><p><br /></p><h3 id=\"keyargs\">💡KeyArgs</h3><p>If a field accepts arguments, you can specify an array of keyArgs in the field’s FieldPolicy. This array indicates which arguments are key arguments that affect the field’s return value. <strong>Specifying this array can help reduce the amount of duplicate data in your cache.</strong><br /></p><p>👉 Key Argument에 명시된 필드에 대해서는 중복을 제외시키는 것 같다. merge 된 데이터를 조회해야 하므로 limit, page 를 필드로 넣으면 정상적으로 캐시 데이터가 조회 되지 않는다.</p><p><br /><br /></p><p>+ 캐시 사용 안하고 Query 를 업데이트 하는 방법</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"nx\">updateQuery</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"nx\">previousResult</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">fetchMoreResult</span> <span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>   <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">fetchMoreResult</span> <span class=\"o\">||</span> <span class=\"nx\">fetchMoreResult</span><span class=\"p\">.</span><span class=\"nx\">images</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">===</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>     <span class=\"nx\">setIsLoadingMore</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">);</span>     <span class=\"k\">return</span> <span class=\"nx\">previousResult</span><span class=\"p\">;</span>   <span class=\"p\">}</span>   <span class=\"nx\">setCurrentPage</span><span class=\"p\">(</span><span class=\"nx\">nextPage</span><span class=\"p\">);</span>   <span class=\"k\">return</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">assign</span><span class=\"p\">({},</span> <span class=\"nx\">previousResult</span><span class=\"p\">,</span> <span class=\"p\">{</span>     <span class=\"na\">images</span><span class=\"p\">:</span> <span class=\"p\">[</span>       <span class=\"p\">...</span><span class=\"nx\">previousResult</span><span class=\"p\">.</span><span class=\"nx\">images</span><span class=\"p\">,</span>       <span class=\"p\">...</span><span class=\"nx\">fetchMoreResult</span><span class=\"p\">.</span><span class=\"nx\">images</span><span class=\"p\">,</span>     <span class=\"p\">],</span>   <span class=\"p\">});</span> <span class=\"p\">},</span></code></pre></div></div><p><br /><br />결과는 요거</p><p><img src=\"https://user-images.githubusercontent.com/56527636/232790566-bba55a35-4312-44a0-a79d-8352a1c2484d.gif\" alt=\"Apr-18-2023 22-21-22\" width=\"470\" /></p><p><br /><br /><br />참고자료는<br /><a href=\"https://www.apollographql.com/docs/apollo-server/\" target=\"\\_blank\">Apollo GraphQL</a> 와 챗지피티! 🥲</p>",
            "url": "https://jheehg.github.io/2023/04/18/infinite-scroll-using-graphql",
            
            
            
            "tags": ["react","graphql","apollo"],
            
            "date_published": "2023-04-18T00:00:00+00:00",
            "date_modified": "2023-04-18T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2023/02/27/controlled-uncontrolled-component-with-mui-and-react-hook-form",
            "title": "material UI 에 react-hook-form 적용 시 주의할 점",
            "summary": "material UI 에 react-hook-form 적용했을 때 겪은 문제점에 대해 공부한 내용입니다.",
            "content_text": "문제 상황  폼 컴포넌트가 사용자의 동작으로 인해 데이터가 변경이 되어야 하는데 값이 바뀌지 않음.  세부 동작          👉 react-hook-form 의 useForm 으로 폼 데이터를 관리 (ex. select, radio, input ..)      👉 특정 함수가 실행될 때 마다 사용자에게 입력 받은 데이터를 reset 에 넣고 실행하여 react-hook-form 에서 관리하는 값을 변경해주는데 정작 폼 컴포넌트 자체는 변화가 없음.      원인  mui 와 같은 controlled component 에 react-hook-form 를 적용할 때는 Controller 라는 Wrapper 컴포넌트를 사용해야 함.  아래 설명과 함께 Controller, Custom Register 두가지 방법으로 처리가 가능하다는 예시가 나와있다.  Controlled mixed with Uncontrolled Components  React Hook Form 은 uncontrolled components 를 수용하지만 controlled components 와도 호환이 가능하다.mui, Antd 와 같은 대부분의 UI 라이브러리는 controlled components 를 지원하도록 구축되어 있다.그러나 React Hook Form 을 적용하면 controlled components 의 리렌더링도 또한 optimize 가 가능하다.https://react-hook-form.com/advanced-usage#ControlledmixedwithUncontrolledComponents+ 추가로 참고할 내용React Hook Form 는 uncontrolled components 와 native inputs 을 지원하는데React-Select, AntD and MUI와 같은 controlled component 에도 적용을 하기 위해서는 Controller 라는 wrapper 를 사용할 수 있다.이미 Controller 자체로도 registration 과정을 거치고 있으니 input 에 다시 register 를 사용하지 않아도 된다.https://react-hook-form.com/api/usecontroller/controller/#example생각해보면 Controllered Component, Uncontrolled Component 에 대해 정확하게 이해를 못한 상태에서 사용하고 있던 것 같아 개념을 다시 정리해보았다.Controllered Component vs UnControlled ComponentControllered Component폼 컴포넌트 (input, checkbox, or select..) 의 상태에 대한 매니징은 서로 다른 방법으로 할 수 있다.Controllered component 는 매니징을 리액트 동작에 맡기는 방법이다. 사용자가 입력값을 바꾸면 리액트의 로컬상태 값도 같이 바뀌기 때문에 철저하게 로컬상태와 동기화 된다. 폼에 값이 입력되면 onChange 이벤트 핸들러를 통해 value 값을 변경한다. UnControlled Component반면 UnControllered component 의 경우 DOM 에 의해서 관리되고 ref 를 통해서 이 컴포넌트에 접근을 한다. 컴포넌트의 값을 바꾸고 싶으면 해당 DOM node 에 직접 접근해서 값을 바꾸게 되는데 이는 관리를 좀 더 까다롭게 만들기도 한다.react-hook-form 에서 제공하는 Controller 컴포넌트를 사용하여 변경하였다.return (   &lt;FormControl&gt;      &lt;FormLabel id=“select-label”&gt;{label}&lt;/FormLabel&gt;         &lt;Controller            control={control}            name={name}            render={({ field }) =&gt; {               return (                  &lt;Select {...field}&gt;                     {data?.map((option) =&gt; (                        &lt;MenuItem key={option.value} value={option.value}&gt;                           {option.name}                        &lt;/MenuItem&gt;                     ))}                  &lt;/Select&gt;               );            }}         /&gt;   &lt;/FormControl&gt;);정리  mui 컴포넌트를 react-hook-form 으로 관리할 경우 controlled component 를 uncontrolled component 방법으로 제어 중인지 확인한다.  controlled component 방법을 적용할 경우 Controller 라는 Wrapper component 를 사용한다.  그 외에도 값이 의도한 대로 변경이 되지 않을 경우 ref 로 컴포넌트가 관리되는지 확인이 필요하다.",
            "content_html": "<p><br /></p><h3 id=\"문제-상황\">문제 상황</h3><ul>  <li>폼 컴포넌트가 사용자의 동작으로 인해 데이터가 변경이 되어야 하는데 값이 바뀌지 않음.</li>  <li>세부 동작    <ul>      <li>👉 <code class=\"language-plaintext highlighter-rouge\">react-hook-form</code> 의 <code class=\"language-plaintext highlighter-rouge\">useForm</code> 으로 폼 데이터를 관리 (ex. select, radio, input ..)</li>      <li>👉 특정 함수가 실행될 때 마다 사용자에게 입력 받은 데이터를 <code class=\"language-plaintext highlighter-rouge\">reset</code> 에 넣고 실행하여 <code class=\"language-plaintext highlighter-rouge\">react-hook-form</code> 에서 관리하는 값을 변경해주는데 정작 폼 컴포넌트 자체는 변화가 없음.</li>    </ul>  </li></ul><p><br /></p><h3 id=\"원인\">원인</h3><ul>  <li><code class=\"language-plaintext highlighter-rouge\">mui</code> 와 같은 <code class=\"language-plaintext highlighter-rouge\">controlled component</code> 에 <code class=\"language-plaintext highlighter-rouge\">react-hook-form</code> 를 적용할 때는 <code class=\"language-plaintext highlighter-rouge\">Controller</code> 라는 Wrapper 컴포넌트를 사용해야 함.</li>  <li>아래 설명과 함께 <strong>Controller</strong>, <strong>Custom Register</strong> 두가지 방법으로 처리가 가능하다는 예시가 나와있다.</li></ul><p><br /></p><blockquote>  <h3 id=\"controlled-mixed-with-uncontrolled-components\">Controlled mixed with Uncontrolled Components</h3>  <p>React Hook Form 은 uncontrolled components 를 수용하지만 controlled components 와도 호환이 가능하다.mui, Antd 와 같은 대부분의 UI 라이브러리는 controlled components 를 지원하도록 구축되어 있다.그러나 React Hook Form 을 적용하면 controlled components 의 리렌더링도 또한 optimize 가 가능하다.</p></blockquote><p><a href=\"https://react-hook-form.com/advanced-usage#ControlledmixedwithUncontrolledComponents\">https://react-hook-form.com/advanced-usage#ControlledmixedwithUncontrolledComponents</a></p><p><br /></p><p>+ 추가로 참고할 내용</p><p>React Hook Form 는 uncontrolled components 와 native inputs 을 지원하는데React-Select, AntD and MUI와 같은 controlled component 에도 적용을 하기 위해서는 Controller 라는 wrapper 를 사용할 수 있다.</p><p>이미 Controller 자체로도 registration 과정을 거치고 있으니 input 에 다시 register 를 사용하지 않아도 된다.</p><p><a href=\"https://react-hook-form.com/api/usecontroller/controller/#example\">https://react-hook-form.com/api/usecontroller/controller/#example</a></p><p><br /><br /></p><p>생각해보면 Controllered Component, Uncontrolled Component 에 대해 정확하게 이해를 못한 상태에서 <br />사용하고 있던 것 같아 개념을 다시 정리해보았다.</p><p><br /><br /></p><h3 id=\"controllered-component-vs-uncontrolled-component\">Controllered Component vs UnControlled Component</h3><h4 id=\"controllered-component\">Controllered Component</h4><p>폼 컴포넌트 (input, checkbox, or select..) 의 상태에 대한 매니징은 서로 다른 방법으로 할 수 있다.<br /><code class=\"language-plaintext highlighter-rouge\">Controllered component</code> 는 매니징을 리액트 동작에 맡기는 방법이다. <br />사용자가 입력값을 바꾸면 리액트의 로컬상태 값도 같이 바뀌기 때문에 철저하게 로컬상태와 동기화 된다. <br />폼에 값이 입력되면 <code class=\"language-plaintext highlighter-rouge\">onChange</code> 이벤트 핸들러를 통해 <code class=\"language-plaintext highlighter-rouge\">value</code> 값을 변경한다. <br /><br /></p><h4 id=\"uncontrolled-component\">UnControlled Component</h4><p>반면 <code class=\"language-plaintext highlighter-rouge\">UnControllered component</code> 의 경우 <code class=\"language-plaintext highlighter-rouge\">DOM</code> 에 의해서 관리되고 <code class=\"language-plaintext highlighter-rouge\">ref</code> 를 통해서 이 컴포넌트에 접근을 한다. <br />컴포넌트의 값을 바꾸고 싶으면 해당 <code class=\"language-plaintext highlighter-rouge\">DOM node</code> 에 직접 접근해서 값을 바꾸게 되는데 이는 관리를 좀 더 까다롭게 만들기도 한다.<br /><br /></p><p>react-hook-form 에서 제공하는 Controller 컴포넌트를 사용하여 변경하였다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">return</span> <span class=\"p\">(</span>   <span class=\"o\">&lt;</span><span class=\"nx\">FormControl</span><span class=\"o\">&gt;</span>      <span class=\"o\">&lt;</span><span class=\"nx\">FormLabel</span> <span class=\"nx\">id</span><span class=\"o\">=</span><span class=\"err\">“</span><span class=\"nx\">select</span><span class=\"o\">-</span><span class=\"nx\">label</span><span class=\"err\">”</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"nx\">label</span><span class=\"p\">}</span><span class=\"o\">&lt;</span><span class=\"sr\">/FormLabel</span><span class=\"err\">&gt;</span>         <span class=\"o\">&lt;</span><span class=\"nx\">Controller</span>            <span class=\"nx\">control</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">control</span><span class=\"p\">}</span>            <span class=\"nx\">name</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">name</span><span class=\"p\">}</span>            <span class=\"nx\">render</span><span class=\"o\">=</span><span class=\"p\">{({</span> <span class=\"nx\">field</span> <span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>               <span class=\"k\">return</span> <span class=\"p\">(</span>                  <span class=\"o\">&lt;</span><span class=\"nx\">Select</span> <span class=\"p\">{...</span><span class=\"nx\">field</span><span class=\"p\">}</span><span class=\"o\">&gt;</span>                     <span class=\"p\">{</span><span class=\"nx\">data</span><span class=\"p\">?.</span><span class=\"nx\">map</span><span class=\"p\">((</span><span class=\"nx\">option</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">(</span>                        <span class=\"o\">&lt;</span><span class=\"nx\">MenuItem</span> <span class=\"nx\">key</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">option</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">}</span> <span class=\"nx\">value</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">option</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">}</span><span class=\"o\">&gt;</span>                           <span class=\"p\">{</span><span class=\"nx\">option</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">}</span>                        <span class=\"o\">&lt;</span><span class=\"sr\">/MenuItem</span><span class=\"err\">&gt;</span>                     <span class=\"p\">))}</span>                  <span class=\"o\">&lt;</span><span class=\"sr\">/Select</span><span class=\"err\">&gt;</span>               <span class=\"p\">);</span>            <span class=\"p\">}}</span>         <span class=\"sr\">/</span><span class=\"err\">&gt;</span>   <span class=\"o\">&lt;</span><span class=\"sr\">/FormControl</span><span class=\"err\">&gt;</span><span class=\"p\">);</span></code></pre></div></div><p><br /></p><h3 id=\"정리\">정리</h3><ul>  <li>mui 컴포넌트를 react-hook-form 으로 관리할 경우 controlled component 를 uncontrolled component 방법으로 제어 중인지 확인한다.</li>  <li>controlled component 방법을 적용할 경우 <code class=\"language-plaintext highlighter-rouge\">Controller</code> 라는 Wrapper component 를 사용한다.</li>  <li>그 외에도 값이 의도한 대로 변경이 되지 않을 경우 <code class=\"language-plaintext highlighter-rouge\">ref</code> 로 컴포넌트가 관리되는지 확인이 필요하다.</li></ul><p><br /></p>",
            "url": "https://jheehg.github.io/2023/02/27/controlled-uncontrolled-component-with-mui-and-react-hook-form",
            
            
            
            "tags": ["react-hook-form","react","material UI"],
            
            "date_published": "2023-02-27T00:00:00+00:00",
            "date_modified": "2023-02-27T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2023/02/12/react-query-important-defaults",
            "title": "react-query 중요한 기본 개념들 정리",
            "summary": "react-query 기본 개념들에 대한 글입니다.",
            "content_text": "기본 옵션들👉 StaleTimeuseQuery 는 기본적으로 캐시된 데이터를 오래된 상태라고 간주한다.(오래된 상태라고 간주하면 새로운 데이터를 요청하게 되므로)이 기본적으로 적용된 옵션을 막으려면 전역적으로 또는 개별적으로 useQuery 를 호출할 때staleTime 옵션을 길게 적용하면 쿼리를 refetch 가 자주 실행되지 않도록 할 수 있다. 기본값은 0 이다.Stale query 는 아래 환경에서 다시 refetch 가 일어나는데 각 환경마다 조건을 변경해주면 된다.  refetchOnMount: 쿼리 마운트의 새 인스턴스가 생성될 때  refetchOnWindowFocus: 윈도우 창이 다시 포커스될 때  refetchOnReconnect: 네트워크가 재연결될 때  refetchInterval: 쿼리의 refetch interval 이 다시 주어질 때👉 cacheTime쿼리 결과가 더이상 active 상태가 아닌 useQuery 인스턴스 또는 query observer 들은 inactive 로 분류되어 캐시에 남아있게 된다.기본적으로 inactive 된 쿼리들은 5분 이후에 가바지 콜렉터 대상이 되는데 이를 변경하려면cacheTIme 옵션을 변경한다. 기본값은 5분으로 설정되어 있음.\\* fetch 된 이후에는 staleTime 영향을 먼저 받고 주어진 stale 타임아웃이 끝날 경우 캐시된 데이터에서 찾게 된다. ✳️ cache-time 과 stale-time 관계  stale-time 이 종료되어 stale 상태가 되면 서버에서 fetch 해서 새 데이터를 가져오기 전까지, 캐시된 데이터를 보여준다. 즉, cache-time 과 상관없이 stale-time 이 종료되면 다시 fetch 를 한다.  cache-time 은 데이터가 stale 상태가 되기 전까지 캐시된 데이터를 가져올 수 있는 duration 을 설정한 것이다.  그래서 stale-time &lt; cache-time 으로 설정하는 것이 좋다.  stale-time 은 요청하는 데이터가 얼마나 자주 변경되는지에 따라 설정한다.https://www.codemzy.com/blog/react-query-cachetime-staletime👉 retry / retryDelay쿼리의 오류가 잡혀서 화면에 보이지기 전까지 3번의 retry를 하게 되는데 이를 조정하려면 retry 옵션 또는 retryDelay 를 변경하면 된다.👉 config.isDataEqual쿼리 결과는 기본적으로 데이터가 변경된게 없는지 구조적으로 감지하고 만약 변경된게 없다면 데이터는 변경되지 않는 값을 참조하게 되고 이는 useMemo, useCallback 으로 값을 유지하고자 할 때 많은 도움이 되도록 한다.이 기능은 JSON 호환타입일 때만 적용되고 나머지 타입에 대해서는 항상 변경된 값으로 간주한다.JSON 호환 타입 외에도 모든 타입에 같은 기능을 적용하고 싶다면 config.isDataEqual 을 사용하면 된다.caching 데이터를 사용하기 위해 알아야 할 점👉 queryKeys 설정// string-onlyuseQuery('todos', ...)// array keysuseQuery(['todo', 5], ...)// array key 는 순서가 다르면 다른 키로 간주한다.useQuery(['todos', status, page], ...)useQuery(['todos', page, status], ...)// object 은 순서 상관없이 같은 키로 간주한다. 아래 두 개는 같은 키.// query string 은 사용자의 입력 순서에 따라 달라질 수 있으므로 object 로 키 값을 받도록 한다.useQuery(['todos', { status, page }], ...)useQuery(['todos', { page, status, other: undefined }], ...)👉 caching Lifecycle  쿼리 인스턴스 생성  background refetching  쿼리 inative 상태로 변경  Garbage Collection아래 과정 참고:      useQuery(‘todos’, fetchTodos) 의 인스턴스가 마운트되었다.해당 쿼리키로 쿼리가 만들어진 적이 없으므로 네트워크에 데이터 fetching 요청을 하게 된다.– ‘todos’와 fetchTodos 를 유니크한 식별자로 사용하면서 이를 캐싱하게 된다. – staleTime 의 기본값은 0 이므로 쿼리가 실행되자마자 stale 상태로 간주하게 된다.         useQuery(‘todos’, fetchTodos) 의 두번째 인스턴스가 마운트되었다.– 첫번째 인스턴스로 인해 쿼리가 캐시되어 있는 상태이므로 데이터는 캐시된 데이터를 가져오게 된다.        새 인스턴스가 화면에 나타났으므로 background refetch 는 각 쿼리에 의해 trigger 된다.– fetch 가 성공했다면 두 인스턴스 모두 새 데이터로 업데이트 된다.        useQuery(‘todos’, fetchTodos) 의 각 인스턴스는 언마운트되고 더이상 사용되지 않는다.– 각 쿼리의 인스턴스는 더이상 active 상태가 아니므로 캐시 타임아웃(5분)이 쿼리에 설정되게 된다.        캐시 타임아웃이 다 진행되기 전에 또 다른 useQuery(‘todos’, fetchTodos) 마운트의 인스턴스가 생성되면 fetchTodos 함수가 새 데이터와 함께 쿼리가 실행되는 동안에 현재 사용가능한 캐시된 데이터를 즉시 리턴하게 된다.        가장 마지막 인스턴스가 언마운트된다.        useQuery(‘todos’, fetchTodos) 쿼리가 5분간 사용되지 않을 경우 데이터가 가비지 콜렉터에 의해 제거되게 된다.  아래 공식문서를 참고해서 정리했습니다. 개인적인 학습 목적으로 번역한 것이므로 잘못된 내용이 있을 수 있습니다.https://react-query-v3.tanstack.com/guides/important-defaults",
            "content_html": "<p><br /></p><h1 id=\"기본-옵션들\">기본 옵션들</h1><h3 id=\"-staletime\">👉 StaleTime</h3><p>useQuery 는 기본적으로 캐시된 데이터를 오래된 상태라고 간주한다.<br />(오래된 상태라고 간주하면 새로운 데이터를 요청하게 되므로)<br />이 기본적으로 적용된 옵션을 막으려면 전역적으로 또는 개별적으로 useQuery 를 호출할 때<br />staleTime 옵션을 길게 적용하면 쿼리를 refetch 가 자주 실행되지 않도록 할 수 있다. 기본값은 0 이다.</p><p>Stale query 는 아래 환경에서 다시 refetch 가 일어나는데 각 환경마다 조건을 변경해주면 된다.</p><ul>  <li>refetchOnMount: 쿼리 마운트의 새 인스턴스가 생성될 때</li>  <li>refetchOnWindowFocus: 윈도우 창이 다시 포커스될 때</li>  <li>refetchOnReconnect: 네트워크가 재연결될 때</li>  <li>refetchInterval: 쿼리의 refetch interval 이 다시 주어질 때</li></ul><p><br /></p><h3 id=\"-cachetime\">👉 cacheTime</h3><p>쿼리 결과가 더이상 active 상태가 아닌 useQuery 인스턴스 또는 query observer 들은 inactive 로 분류되어 캐시에 남아있게 된다.기본적으로 inactive 된 쿼리들은 5분 이후에 가바지 콜렉터 대상이 되는데 이를 변경하려면cacheTIme 옵션을 변경한다. 기본값은 5분으로 설정되어 있음.</p><strike>\\* fetch 된 이후에는 staleTime 영향을 먼저 받고 주어진 stale 타임아웃이 끝날 경우 캐시된 데이터에서 찾게 된다. </strike><p><br />✳️ <strong>cache-time 과 stale-time 관계</strong></p><ul>  <li>stale-time 이 종료되어 stale 상태가 되면 서버에서 fetch 해서 새 데이터를 가져오기 전까지, 캐시된 데이터를 보여준다. 즉, cache-time 과 상관없이 <strong>stale-time 이 종료되면 다시 fetch 를 한다.</strong></li>  <li>cache-time 은 데이터가 stale 상태가 되기 전까지 캐시된 데이터를 가져올 수 있는 duration 을 설정한 것이다.</li>  <li>그래서 <strong>stale-time &lt; cache-time</strong> 으로 설정하는 것이 좋다.</li>  <li>stale-time 은 요청하는 데이터가 <strong>얼마나 자주 변경되는지</strong>에 따라 설정한다.</li></ul><p><a href=\"https://www.codemzy.com/blog/react-query-cachetime-staletime\">https://www.codemzy.com/blog/react-query-cachetime-staletime</a></p><p><br /></p><h3 id=\"-retry--retrydelay\">👉 retry / retryDelay</h3><p>쿼리의 오류가 잡혀서 화면에 보이지기 전까지 3번의 retry를 하게 되는데 이를 조정하려면 retry 옵션 또는 retryDelay 를 변경하면 된다.</p><p><br /></p><h3 id=\"-configisdataequal\">👉 config.isDataEqual</h3><p>쿼리 결과는 기본적으로 데이터가 변경된게 없는지 구조적으로 감지하고 만약 변경된게 없다면 데이터는 변경되지 않는 값을 참조하게 되고 이는 useMemo, useCallback 으로 값을 유지하고자 할 때 많은 도움이 되도록 한다.<br />이 기능은 JSON 호환타입일 때만 적용되고 나머지 타입에 대해서는 항상 변경된 값으로 간주한다.<br />JSON 호환 타입 외에도 모든 타입에 같은 기능을 적용하고 싶다면 config.isDataEqual 을 사용하면 된다.</p><p><br /></p><h1 id=\"caching-데이터를-사용하기-위해-알아야-할-점\">caching 데이터를 사용하기 위해 알아야 할 점</h1><h3 id=\"-querykeys-설정\">👉 queryKeys 설정</h3><div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// string-only</span><span class=\"nx\">useQuery</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">todos</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">...)</span><span class=\"c1\">// array keys</span><span class=\"nx\">useQuery</span><span class=\"p\">([</span><span class=\"dl\">'</span><span class=\"s1\">todo</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">],</span> <span class=\"p\">...)</span></code></pre></div></div><p><br /></p><div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// array key 는 순서가 다르면 다른 키로 간주한다.</span><span class=\"nx\">useQuery</span><span class=\"p\">([</span><span class=\"dl\">'</span><span class=\"s1\">todos</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">status</span><span class=\"p\">,</span> <span class=\"nx\">page</span><span class=\"p\">],</span> <span class=\"p\">...)</span><span class=\"nx\">useQuery</span><span class=\"p\">([</span><span class=\"dl\">'</span><span class=\"s1\">todos</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"nx\">page</span><span class=\"p\">,</span> <span class=\"nx\">status</span><span class=\"p\">],</span> <span class=\"p\">...)</span><span class=\"c1\">// object 은 순서 상관없이 같은 키로 간주한다. 아래 두 개는 같은 키.</span><span class=\"c1\">// query string 은 사용자의 입력 순서에 따라 달라질 수 있으므로 object 로 키 값을 받도록 한다.</span><span class=\"nx\">useQuery</span><span class=\"p\">([</span><span class=\"dl\">'</span><span class=\"s1\">todos</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">status</span><span class=\"p\">,</span> <span class=\"nx\">page</span> <span class=\"p\">}],</span> <span class=\"p\">...)</span><span class=\"nx\">useQuery</span><span class=\"p\">([</span><span class=\"dl\">'</span><span class=\"s1\">todos</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">page</span><span class=\"p\">,</span> <span class=\"nx\">status</span><span class=\"p\">,</span> <span class=\"na\">other</span><span class=\"p\">:</span> <span class=\"kc\">undefined</span> <span class=\"p\">}],</span> <span class=\"p\">...)</span></code></pre></div></div><p><br /></p><h3 id=\"-caching-lifecycle\">👉 caching Lifecycle</h3><ul>  <li>쿼리 인스턴스 생성</li>  <li>background refetching</li>  <li>쿼리 inative 상태로 변경</li>  <li>Garbage Collection</li></ul><p><br /></p><p>아래 과정 참고:</p><ol>  <li>    <p>useQuery(‘todos’, fetchTodos) 의 인스턴스가 마운트되었다.<br />해당 쿼리키로 쿼리가 만들어진 적이 없으므로 네트워크에 데이터 fetching 요청을 하게 된다.<br />– ‘todos’와 fetchTodos 를 유니크한 식별자로 사용하면서 이를 캐싱하게 된다. <br />– staleTime 의 기본값은 0 이므로 쿼리가 실행되자마자 stale 상태로 간주하게 된다. <br /><br /></p>  </li>  <li>    <p>useQuery(‘todos’, fetchTodos) 의 두번째 인스턴스가 마운트되었다.<br />– 첫번째 인스턴스로 인해 쿼리가 캐시되어 있는 상태이므로 데이터는 캐시된 데이터를 가져오게 된다.<br /><br /></p>  </li>  <li>    <p>새 인스턴스가 화면에 나타났으므로 background refetch 는 각 쿼리에 의해 trigger 된다.<br />– fetch 가 성공했다면 두 인스턴스 모두 새 데이터로 업데이트 된다.<br /><br /></p>  </li>  <li>    <p>useQuery(‘todos’, fetchTodos) 의 각 인스턴스는 언마운트되고 더이상 사용되지 않는다.<br />– 각 쿼리의 인스턴스는 더이상 active 상태가 아니므로 캐시 타임아웃(5분)이 쿼리에 설정되게 된다.<br /><br /></p>  </li>  <li>    <p>캐시 타임아웃이 다 진행되기 전에 또 다른 useQuery(‘todos’, fetchTodos) 마운트의 인스턴스가 생성되면 fetchTodos 함수가 새 데이터와 함께 쿼리가 실행되는 동안에 현재 사용가능한 캐시된 데이터를 즉시 리턴하게 된다.<br /><br /></p>  </li>  <li>    <p>가장 마지막 인스턴스가 언마운트된다.<br /><br /></p>  </li>  <li>    <p>useQuery(‘todos’, fetchTodos) 쿼리가 5분간 사용되지 않을 경우 데이터가 가비지 콜렉터에 의해 제거되게 된다.</p>  </li></ol><p><br /><br /><br /></p><p>아래 공식문서를 참고해서 정리했습니다. <br />개인적인 학습 목적으로 번역한 것이므로 잘못된 내용이 있을 수 있습니다.<br /><a href=\"https://react-query-v3.tanstack.com/guides/important-defaults\">https://react-query-v3.tanstack.com/guides/important-defaults</a></p>",
            "url": "https://jheehg.github.io/2023/02/12/react-query-important-defaults",
            
            
            
            "tags": ["react-query","react"],
            
            "date_published": "2023-02-12T00:00:00+00:00",
            "date_modified": "2023-02-12T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2023/02/11/react-table-react-query",
            "title": "react-query, react-table 와 상태관리",
            "summary": "react-query, react-table 를 사용하면서 겪은 문제점에 대한 글입니다. (해결중)",
            "content_text": "이번 새로운 프로젝트를 진행하면서 react-query 를 처음 사용하고 있는 중인데 역시 라이브러리가 가진 개념과 방향을 이해하는 게 너무 중요하다는 것을 깨닫는 중이다.react-query 를 사용해서 데이터를 fetch 할 때는 되도록 state 에 저장해서 관리하지 않아야 할 것 같다.생각해보면 그럴 필요도 없고 state 값이 업데이트 되면서 원치 않는 이펙트가 발생되기도 한다.(애초에 react-query 를 쓰면서 왜 state 으로 관리 할 생각을 했는지.. 나자신이여..😂)현재 공통적으로 문제가 되는 부분은 state 이 업데이트 되면서 그 사이에 기존 값이 보였다가 그 후에 변경이 문제이다.select 컴포넌트에서 옵션으로 사용될 데이터를 useQuery 로 가져오고 그 데이터 값을특정 함수를 통해 가공 후에 옵션 prop 으로 넘겨준다.여기서 이 옵션값을 state 로 저장할 필요가 없다. 이 불필요한 state 때문에 select 컴포넌트가 값이 변경 될 때마다 깜빡이면서 잠시 사이에 기존 값을 보여주고 난 후에 변경되게 된다. (으으 😵)const SomeSelect = ({queryKey, apiFn, renderFunction, ...someProps}) =&gt; {  const [options, setOptions] = useState&lt;someInterface[]&gt;([]);  const { data, isSuccess } = customHookForUseQuery({    queryKey,    queryFn: apiFn,  });  // 문제되는 부분  useEffect(() =&gt; {    if (isSuccess) {      const option = renderFunction        ? data?.map(renderFunction)        : data?.map(defaultFunction);      setOptions(option);    }  }, [isSuccess, queryKey]);    return (      &lt;Select        options={options}        ref={ref}        {...somePropsForSelect}      /&gt;    );  }};아래 방법으로 수정하니 해결되었다. useMemo 를 써도 호출하는 횟수에 개선은 없어서 사용하지는 않았다.const SomeSelect = ({queryKey, apiFn, renderFunction, ...someProps}) =&gt; {  const { data, isSuccess } = customHookForUseQuery({    queryKey,    queryFn: apiFn,  });  // 변경한 부분  const options = renderFunction ? data?.map(renderFunction) : data?.map(defaultFunction);    return (      &lt;Select        options={options}        ref={ref}        {...somePropsForSelect}      /&gt;    );  }};또 다른 문제는..?테이블 각 row 의 cell 에서 input 으로 값을 수정해야 하는 화면이 있는데기존 프로젝트에서는 react-hook-form 이라는 폼 라이브러리를 사용했어서 이러한 문제가 없었는데라이브러리 없이 사용하니 생각지도 못한 문제점에 부딪혔다.react-table 에서는 editable data 를 처리할때 다음과 같은 솔루션을 제안한다. (왜냐면 onChange 이벤트만을 사용 시 포커스가 input 밖으로 빠지는 버그가 있다)  onChange 이벤트에서는 cell 내부에서 local state 으로 value 를 관리해서 즉시 업데이트 한다.  이후 onBlur 이벤트에서는 업데이트된 값을 최종적으로 테이블 밖에 선언된 로컬 state 에 업데이트 한다.onBlur 로 로컬 state 값을 수정하고 난 뒤 다시 변경된 데이터가 react-table 컴포넌트에 전달되게 된다.그럼 테이블 훅에서는 다시 이 데이터를 받아 새로운 row 데이터를 리턴하고 각 table row 에 렌더링하는 일을 할 것이다.이 과정에는 문제가 없다. 문제는 이렇게 상태값이 변경될 때마다 순간적으로 기존 값을 보여주다가 업데이트가 된다는 것이다. 신기한건 react-table 에서 보여주는 예시 프로젝트에는 이런 현상이 없는데 뭘까.그래서 생각해 본 해결방안은  일부 문제되는 페이지에 대한 react-table 사용을 포기하기 -&gt; 아주 쉬운 방법이긴 하지만..  react-hook-form 라이브러리를 적용하기 -&gt; 폼이 들어가는 페이지 모두 수정해야 하는 문제가 있다  state 으로 관리하지 않고 폼 submit 할때 FormData 객체로 값을 생성시켜 서버에 sending 하기 -&gt; state 구조가 복잡하므로 FormData 로 생성시키는 작업이 딱히 적절하지 않아보인다.  what else..? 항상 드는 생각이지만 리액트 동작에 대한 컨트롤은 여전히 어렵다는 것이다.아직 해결중이므로 나중에 어떻게 해결했는지 더 이어서 작성해야겠다.https://react-table-v7.tanstack.com/docs/examples/editable-data",
            "content_html": "<p>이번 새로운 프로젝트를 진행하면서 <strong>react-query</strong> 를 처음 사용하고 있는 중인데 <br />역시 라이브러리가 가진 개념과 방향을 이해하는 게 너무 중요하다는 것을 깨닫는 중이다.</p><p><strong>react-query</strong> 를 사용해서 데이터를 <strong>fetch</strong> 할 때는 되도록 <strong>state</strong> 에 저장해서 관리하지 않아야 할 것 같다.<br />생각해보면 그럴 필요도 없고 <strong>state</strong> 값이 업데이트 되면서 원치 않는 이펙트가 발생되기도 한다.<br />(애초에 <strong>react-query</strong> 를 쓰면서 왜 <strong>state</strong> 으로 관리 할 생각을 했는지.. 나자신이여..😂)<br /><br /></p><p>현재 공통적으로 문제가 되는 부분은 <strong>state</strong> 이 업데이트 되면서 그 사이에 기존 값이 보였다가 그 후에 변경이 문제이다.<br /><br /></p><p>select 컴포넌트에서 옵션으로 사용될 데이터를 <strong>useQuery</strong> 로 가져오고 그 데이터 값을<br />특정 함수를 통해 가공 후에 옵션 <strong>prop</strong> 으로 넘겨준다.<br /></p><p>여기서 이 옵션값을 <strong>state</strong> 로 저장할 필요가 없다. 이 불필요한 <strong>state</strong> 때문에 select 컴포넌트가 값이 변경 <br />될 때마다 깜빡이면서 잠시 사이에 기존 값을 보여주고 난 후에 변경되게 된다. (으으 😵)<br /><br /></p><div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">SomeSelect</span> <span class=\"o\">=</span> <span class=\"p\">({</span><span class=\"nx\">queryKey</span><span class=\"p\">,</span> <span class=\"nx\">apiFn</span><span class=\"p\">,</span> <span class=\"nx\">renderFunction</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">someProps</span><span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"p\">[</span><span class=\"nx\">options</span><span class=\"p\">,</span> <span class=\"nx\">setOptions</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"o\">&lt;</span><span class=\"nx\">someInterface</span><span class=\"p\">[]</span><span class=\"o\">&gt;</span><span class=\"p\">([]);</span>  <span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">isSuccess</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">customHookForUseQuery</span><span class=\"p\">({</span>    <span class=\"nx\">queryKey</span><span class=\"p\">,</span>    <span class=\"na\">queryFn</span><span class=\"p\">:</span> <span class=\"nx\">apiFn</span><span class=\"p\">,</span>  <span class=\"p\">});</span>  <span class=\"c1\">// 문제되는 부분</span>  <span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">isSuccess</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"kd\">const</span> <span class=\"nx\">option</span> <span class=\"o\">=</span> <span class=\"nx\">renderFunction</span>        <span class=\"p\">?</span> <span class=\"nx\">data</span><span class=\"p\">?.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">renderFunction</span><span class=\"p\">)</span>        <span class=\"p\">:</span> <span class=\"nx\">data</span><span class=\"p\">?.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">defaultFunction</span><span class=\"p\">);</span>      <span class=\"nx\">setOptions</span><span class=\"p\">(</span><span class=\"nx\">option</span><span class=\"p\">);</span>    <span class=\"p\">}</span>  <span class=\"p\">},</span> <span class=\"p\">[</span><span class=\"nx\">isSuccess</span><span class=\"p\">,</span> <span class=\"nx\">queryKey</span><span class=\"p\">]);</span>    <span class=\"k\">return</span> <span class=\"p\">(</span>      <span class=\"p\">&lt;</span><span class=\"nc\">Select</span>        <span class=\"na\">options</span><span class=\"p\">=</span><span class=\"si\">{</span><span class=\"nx\">options</span><span class=\"si\">}</span>        <span class=\"na\">ref</span><span class=\"p\">=</span><span class=\"si\">{</span><span class=\"nx\">ref</span><span class=\"si\">}</span>        <span class=\"si\">{</span><span class=\"p\">...</span><span class=\"nx\">somePropsForSelect</span><span class=\"si\">}</span>      <span class=\"p\">/&gt;</span>    <span class=\"p\">);</span>  <span class=\"p\">}</span><span class=\"p\">};</span></code></pre></div></div><p><br />아래 방법으로 수정하니 해결되었다. <strong>useMemo</strong> 를 써도 호출하는 횟수에 개선은 없어서 사용하지는 않았다.<br /></p><div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">SomeSelect</span> <span class=\"o\">=</span> <span class=\"p\">({</span><span class=\"nx\">queryKey</span><span class=\"p\">,</span> <span class=\"nx\">apiFn</span><span class=\"p\">,</span> <span class=\"nx\">renderFunction</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">someProps</span><span class=\"p\">})</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"nx\">data</span><span class=\"p\">,</span> <span class=\"nx\">isSuccess</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">customHookForUseQuery</span><span class=\"p\">({</span>    <span class=\"nx\">queryKey</span><span class=\"p\">,</span>    <span class=\"na\">queryFn</span><span class=\"p\">:</span> <span class=\"nx\">apiFn</span><span class=\"p\">,</span>  <span class=\"p\">});</span>  <span class=\"c1\">// 변경한 부분</span>  <span class=\"kd\">const</span> <span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"nx\">renderFunction</span> <span class=\"p\">?</span> <span class=\"nx\">data</span><span class=\"p\">?.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">renderFunction</span><span class=\"p\">)</span> <span class=\"p\">:</span> <span class=\"nx\">data</span><span class=\"p\">?.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"nx\">defaultFunction</span><span class=\"p\">);</span>    <span class=\"k\">return</span> <span class=\"p\">(</span>      <span class=\"p\">&lt;</span><span class=\"nc\">Select</span>        <span class=\"na\">options</span><span class=\"p\">=</span><span class=\"si\">{</span><span class=\"nx\">options</span><span class=\"si\">}</span>        <span class=\"na\">ref</span><span class=\"p\">=</span><span class=\"si\">{</span><span class=\"nx\">ref</span><span class=\"si\">}</span>        <span class=\"si\">{</span><span class=\"p\">...</span><span class=\"nx\">somePropsForSelect</span><span class=\"si\">}</span>      <span class=\"p\">/&gt;</span>    <span class=\"p\">);</span>  <span class=\"p\">}</span><span class=\"p\">};</span></code></pre></div></div><p><br /><br /></p><h4 id=\"또-다른-문제는\">또 다른 문제는..?</h4><p>테이블 각 <strong>row</strong> 의 <strong>cell</strong> 에서 <strong>input</strong> 으로 값을 수정해야 하는 화면이 있는데<br />기존 프로젝트에서는 <strong>react-hook-form</strong> 이라는 폼 라이브러리를 사용했어서 이러한 문제가 없었는데<br />라이브러리 없이 사용하니 생각지도 못한 문제점에 부딪혔다.</p><p><br /></p><p><strong>react-table</strong> 에서는 <strong>editable data</strong> 를 처리할때 다음과 같은 솔루션을 제안한다. <br />(왜냐면 <strong>onChange</strong> 이벤트만을 사용 시 포커스가 <strong>input</strong> 밖으로 빠지는 버그가 있다)<br /><br /></p><ol>  <li><strong>onChange</strong> 이벤트에서는 <strong>cell</strong> 내부에서 <strong>local state</strong> 으로 <strong>value</strong> 를 관리해서 즉시 업데이트 한다.</li>  <li>이후 <strong>onBlur</strong> 이벤트에서는 업데이트된 값을 최종적으로 테이블 밖에 선언된 <strong>로컬 state</strong> 에 업데이트 한다.<br /><br /></li></ol><p><strong>onBlur</strong> 로 로컬 state 값을 수정하고 난 뒤 다시 변경된 데이터가 react-table 컴포넌트에 전달되게 된다.<br />그럼 테이블 훅에서는 다시 이 데이터를 받아 새로운 row 데이터를 리턴하고 각 table row 에 렌더링하는 일을 할 것이다.<br />이 과정에는 문제가 없다. 문제는 이렇게 상태값이 변경될 때마다 순간적으로 기존 값을 보여주다가 업데이트가 된다는 것이다. <br />신기한건 <strong>react-table</strong> 에서 보여주는 예시 프로젝트에는 이런 현상이 없는데 뭘까.<br /><br /></p><h4 id=\"그래서-생각해-본-해결방안은\">그래서 생각해 본 해결방안은</h4><ol>  <li>일부 문제되는 페이지에 대한 <strong>react-table</strong> 사용을 포기하기 -&gt; <em>아주 쉬운 방법이긴 하지만..</em></li>  <li><strong>react-hook-form</strong> 라이브러리를 적용하기 -&gt; <em>폼이 들어가는 페이지 모두 수정해야 하는 문제가 있다</em></li>  <li>state 으로 관리하지 않고 폼 submit 할때 <strong>FormData</strong> 객체로 값을 생성시켜 서버에 sending 하기 -&gt; <em>state 구조가 복잡하므로 FormData 로 생성시키는 작업이 딱히 적절하지 않아보인다.</em></li>  <li>what else..? <br /><br /></li></ol><p>항상 드는 생각이지만 리액트 동작에 대한 컨트롤은 여전히 어렵다는 것이다.<br />아직 해결중이므로 나중에 어떻게 해결했는지 더 이어서 작성해야겠다.</p><p><br /><br /></p><p><a href=\"https://react-table-v7.tanstack.com/docs/examples/editable-data\">https://react-table-v7.tanstack.com/docs/examples/editable-data</a></p>",
            "url": "https://jheehg.github.io/2023/02/11/react-table-react-query",
            
            
            
            "tags": ["react-table","react-query","react"],
            
            "date_published": "2023-02-11T00:00:00+00:00",
            "date_modified": "2023-02-11T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2023/01/03/getter-property",
            "title": "getter property가 있는 객체 복사하기",
            "summary": "getter property가 있는 객체 복사하기 관련 글입니다.",
            "content_text": "문제 상황:  React 프로젝트에서 object 타입의 상태값의 변경이 필요.  원본 object 의 getter property 내에서 this 와 다른 property 를 참조하고 있다.  원본 object 를 카피해서 getter 를 제외하고 그 외에 property 만 업데이트 하려고 시도했다.  복사한 object 의 getter property 는 여전히 원본의 this 를 가리키고 있어 값이 업데이트 되지 않는 오류 발생.👉 문제 상황 코드const [user, setUser] = useState(() =&gt; ({  userName: name,  userAge: age,  get userInfo() {    if (!this.userName || !this.userAge) {      return '';    }    return `Name: ${this.userName}, Age: ${this.userAge}`;  },}));아래와 같은 spread 방식으로 복사할 경우 getter 까지 복사가 될까?결과는 원본 object의 값을 그대로 쓰고 있었다.userName, userAge 값은 업데이트 되지만 getter property 인 userInfo 가 리턴하는 값은 변경되지 않는다.useEffect(() =&gt; {  setUser({    ...user,    userName: name,    userAge: age,  });}, [name, age]);그렇다면 getter property 는 어떻게 복사할까?구글링으로 열심히 찾아본 결과로는 Object.getOwnPropertyDescriptor 메서드를 사용하라는 솔루션을 받았다.1. Object.getOwnPropertyDescriptor 사용해서 복사해보기useEffect(() =&gt; {  const updateUser = { ...user, userName: name, userAge: age };  const descriptor = Object.getOwnPropertyDescriptor(user, 'userInfo');  Object.defineProperty(    updateUser,    'userInfo',    descriptor as PropertyDescriptor  );  setUser(updateUser);}, [name, age]);다른 방식으로도 해결이 가능할까 시도해보던 중 Object.getOwnPropertyDescriptor 메서드를 사용하지 않고업데이트를 하는 방법을 찾을 수 있었다.2. 원본과 공유하지 않고 재할당해서 사용하기복사하려는 object 의 내용은 변경될 일이 없기 때문에 useMemo 로 생성해준다.해당 object 를 새 변수 updateUser 에 할당하면 this 바인딩이 updateUser 로 되기 때문에 그 이후로 property 값만 바꿔주면 된다.const bsUser = useMemo(  () =&gt; ({    userName: name,    userAge: age,    get userInfo() {      if (!this.userName || !this.userAge) {        return '';      }      return `Name: ${this.userName}, Age: ${this.userAge}`;    },  }),  []);const [user, setUser] = useState(() =&gt; bsUser);// codeuseEffect(() =&gt; {  const updateUser = bsUser;  updateUser.userName = name;  updateUser.userAge = age;  setUser(updateUser);}, [name, age]);아래 참고한 링크 내용에 객체의 모든 property 의 얕은 복사, 깊은 복사에 대한 설명이 잘 나와있다.https://zellwk.com/blog/copy-properties-of-one-object-to-another-object/",
            "content_html": "<p><br /></p><h4 id=\"문제-상황\">문제 상황:</h4><ol>  <li>React 프로젝트에서 object 타입의 상태값의 변경이 필요.</li>  <li>원본 object 의 <code class=\"language-plaintext highlighter-rouge\">getter</code> property 내에서 <code class=\"language-plaintext highlighter-rouge\">this</code> 와 다른 property 를 참조하고 있다.</li>  <li>원본 object 를 카피해서 <code class=\"language-plaintext highlighter-rouge\">getter</code> 를 제외하고 그 외에 property 만 업데이트 하려고 시도했다.</li>  <li>복사한 object 의 <code class=\"language-plaintext highlighter-rouge\">getter</code> property 는 여전히 원본의 <code class=\"language-plaintext highlighter-rouge\">this</code> 를 가리키고 있어 값이 업데이트 되지 않는 오류 발생.</li></ol><p><br /></p><p>👉 문제 상황 코드</p><div class=\"language-tsx highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"p\">[</span><span class=\"nx\">user</span><span class=\"p\">,</span> <span class=\"nx\">setUser</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">({</span>  <span class=\"na\">userName</span><span class=\"p\">:</span> <span class=\"nx\">name</span><span class=\"p\">,</span>  <span class=\"na\">userAge</span><span class=\"p\">:</span> <span class=\"nx\">age</span><span class=\"p\">,</span>  <span class=\"kd\">get</span> <span class=\"nx\">userInfo</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userName</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userAge</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"k\">return</span> <span class=\"dl\">''</span><span class=\"p\">;</span>    <span class=\"p\">}</span>    <span class=\"k\">return</span> <span class=\"s2\">`Name: </span><span class=\"p\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userName</span><span class=\"p\">}</span><span class=\"s2\">, Age: </span><span class=\"p\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userAge</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">;</span>  <span class=\"p\">},</span><span class=\"p\">}));</span></code></pre></div></div><p><br /></p><p>아래와 같은 spread 방식으로 복사할 경우 getter 까지 복사가 될까?<br />결과는 원본 object의 값을 그대로 쓰고 있었다.<br />userName, userAge 값은 업데이트 되지만 getter property 인 userInfo 가 리턴하는 값은 변경되지 않는다.</p><div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"nx\">setUser</span><span class=\"p\">({</span>    <span class=\"p\">...</span><span class=\"nx\">user</span><span class=\"p\">,</span>    <span class=\"na\">userName</span><span class=\"p\">:</span> <span class=\"nx\">name</span><span class=\"p\">,</span>    <span class=\"na\">userAge</span><span class=\"p\">:</span> <span class=\"nx\">age</span><span class=\"p\">,</span>  <span class=\"p\">});</span><span class=\"p\">},</span> <span class=\"p\">[</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">]);</span></code></pre></div></div><p><br /></p><p>그렇다면 getter property 는 어떻게 복사할까?<br />구글링으로 열심히 찾아본 결과로는 <code class=\"language-plaintext highlighter-rouge\">Object.getOwnPropertyDescriptor</code> 메서드를 사용하라는 솔루션을 받았다.</p><p><br /></p><h4 id=\"1-objectgetownpropertydescriptor-사용해서-복사해보기\">1. Object.getOwnPropertyDescriptor 사용해서 복사해보기</h4><div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">updateUser</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"p\">...</span><span class=\"nx\">user</span><span class=\"p\">,</span> <span class=\"na\">userName</span><span class=\"p\">:</span> <span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"na\">userAge</span><span class=\"p\">:</span> <span class=\"nx\">age</span> <span class=\"p\">};</span>  <span class=\"kd\">const</span> <span class=\"nx\">descriptor</span> <span class=\"o\">=</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">getOwnPropertyDescriptor</span><span class=\"p\">(</span><span class=\"nx\">user</span><span class=\"p\">,</span> <span class=\"dl\">'</span><span class=\"s1\">userInfo</span><span class=\"dl\">'</span><span class=\"p\">);</span>  <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">defineProperty</span><span class=\"p\">(</span>    <span class=\"nx\">updateUser</span><span class=\"p\">,</span>    <span class=\"dl\">'</span><span class=\"s1\">userInfo</span><span class=\"dl\">'</span><span class=\"p\">,</span>    <span class=\"nx\">descriptor</span> <span class=\"k\">as</span> <span class=\"nx\">PropertyDescriptor</span>  <span class=\"p\">);</span>  <span class=\"nx\">setUser</span><span class=\"p\">(</span><span class=\"nx\">updateUser</span><span class=\"p\">);</span><span class=\"p\">},</span> <span class=\"p\">[</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">]);</span></code></pre></div></div><p><br />다른 방식으로도 해결이 가능할까 시도해보던 중 <code class=\"language-plaintext highlighter-rouge\">Object.getOwnPropertyDescriptor</code> 메서드를 사용하지 않고업데이트를 하는 방법을 찾을 수 있었다.</p><p><br /></p><h4 id=\"2-원본과-공유하지-않고-재할당해서-사용하기\">2. 원본과 공유하지 않고 재할당해서 사용하기</h4><p><br />복사하려는 object 의 내용은 변경될 일이 없기 때문에 useMemo 로 생성해준다.<br />해당 object 를 새 변수 <code class=\"language-plaintext highlighter-rouge\">updateUser</code> 에 할당하면 this 바인딩이 <code class=\"language-plaintext highlighter-rouge\">updateUser</code> 로 되기 때문에 그 이후로 property 값만 바꿔주면 된다.</p><div class=\"language-ts highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">bsUser</span> <span class=\"o\">=</span> <span class=\"nx\">useMemo</span><span class=\"p\">(</span>  <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">({</span>    <span class=\"na\">userName</span><span class=\"p\">:</span> <span class=\"nx\">name</span><span class=\"p\">,</span>    <span class=\"na\">userAge</span><span class=\"p\">:</span> <span class=\"nx\">age</span><span class=\"p\">,</span>    <span class=\"kd\">get</span> <span class=\"nx\">userInfo</span><span class=\"p\">()</span> <span class=\"p\">{</span>      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userName</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userAge</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"k\">return</span> <span class=\"dl\">''</span><span class=\"p\">;</span>      <span class=\"p\">}</span>      <span class=\"k\">return</span> <span class=\"s2\">`Name: </span><span class=\"p\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userName</span><span class=\"p\">}</span><span class=\"s2\">, Age: </span><span class=\"p\">${</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">userAge</span><span class=\"p\">}</span><span class=\"s2\">`</span><span class=\"p\">;</span>    <span class=\"p\">},</span>  <span class=\"p\">}),</span>  <span class=\"p\">[]</span><span class=\"p\">);</span><span class=\"kd\">const</span> <span class=\"p\">[</span><span class=\"nx\">user</span><span class=\"p\">,</span> <span class=\"nx\">setUser</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"nx\">bsUser</span><span class=\"p\">);</span><span class=\"c1\">// code</span><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"kd\">const</span> <span class=\"nx\">updateUser</span> <span class=\"o\">=</span> <span class=\"nx\">bsUser</span><span class=\"p\">;</span>  <span class=\"nx\">updateUser</span><span class=\"p\">.</span><span class=\"nx\">userName</span> <span class=\"o\">=</span> <span class=\"nx\">name</span><span class=\"p\">;</span>  <span class=\"nx\">updateUser</span><span class=\"p\">.</span><span class=\"nx\">userAge</span> <span class=\"o\">=</span> <span class=\"nx\">age</span><span class=\"p\">;</span>  <span class=\"nx\">setUser</span><span class=\"p\">(</span><span class=\"nx\">updateUser</span><span class=\"p\">);</span><span class=\"p\">},</span> <span class=\"p\">[</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">age</span><span class=\"p\">]);</span></code></pre></div></div><p><br /></p><p>아래 참고한 링크 내용에 객체의 모든 property 의 얕은 복사, 깊은 복사에 대한 설명이 잘 나와있다.<br /></p><p><a href=\"https://zellwk.com/blog/copy-properties-of-one-object-to-another-object/\">https://zellwk.com/blog/copy-properties-of-one-object-to-another-object/</a></p>",
            "url": "https://jheehg.github.io/2023/01/03/getter-property",
            
            
            
            
            
            "date_published": "2023-01-03T00:00:00+00:00",
            "date_modified": "2023-01-03T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2022/08/31/lottie-animation",
            "title": "Lottie Animation 리액트 프로젝트에 적용하기",
            "summary": "리액트 Lottie Animation으로 toggle 버튼을 구현해봅니다.",
            "content_text": "리액트에서 사용 가능한 lottie 모듈 중 lottie-react 를 사용하였다. 어떤 목적으로 사용하는지에 따라 다르겠지만 토글버튼을 사용하기 위해서 프레임 조정 기능을 지원하는 모듈이 필요했다.react-lottie  playSegments를 내부적으로만 사용하기 때문에 forceFlag 값을 따로 지정 못하는 문제점이 있었다.    react-lottie-segments    playSegments를 간단하게 사용할 수 있었지만 지속적으로 관리되는 모듈을 사용하고자 하였다.    고려했던 부분들          클릭 이벤트 발생 시 프레임을 바꿔주려면 playSegments 메서드를 직접 호출해야 함      타입스크립트 지원이 되는 모듈      playSegments(segments, forceFlag){segments: [start, stop],forceFlag: true,}segments\tArray타입\t첫번째, 두번째 인덱스에는 각각 시작 프레임과 정지프레임을 넣어준다. ex. [0, 1] forceFlag\tBoolean 타입\tfalse일 경우, 현재 세그먼트가 완료될 떄까지 기다린다. \ttrue일 경우, 세그먼트 값을 바로 업데이트 한다. (인자를 true로 넘겨줘야 토글이 제대로 동작한다)프레임 지정  toggle 버튼이 시작점에서 ON -&gt; OFF -&gt; ON 순서에 따라 원점으로 돌아오는 동작을 기준으로 한다.  프레임의 초기값은 [0, 1] 로 넣어줘야 시작점에서 멈춰있는 상태로 대기하게 된다.  초기값을 [0, 0] 으로 지정할 경우 애니메이션이 루프를 한번 돌게 되므로 주의한다.  ON -&gt; OFF -&gt; ON 각각의 상태에 따라 프레임 설정을 아래와 같이 지정하였다.            ON(멈춤)      ON → OFF(이동)      OFF(멈춤)      OFF → ON(이동)                  [0, 1]      [0, 전체프레임/2]      [전체프레임/2, 전체프레임/2 + 1]      [전체프레임/2, 전체프레임]      lottie-ReactComponenet, Hook 2가지 타입으로 import해서 사용이 가능하다. 여기서는 Hook을 사용했다.👉 Hook의 사용 const style = {    height: 36,    width: 60,  };  const options = {    loop: false,    autoplay: false,    animationData: jsonData,    rendererSettings: {      preserveAspectRatio: 'xMidYMid slice',    },  };const { View, playSegments, setSpeed } = useLottie(options, style);👉 jsx 리턴  /*   View의 형태는 아래와 같다. lottie-react github 참고    const View = &lt;div style={style} ref={animationContainer} {...rest} /&gt;;  */    return (    &lt;Wrapper      onClick={onToggleHandler}&gt;      {View}    &lt;/Wrapper&gt;  );👉 State 관리 및 playSegments의 사용  playSegments을 호출해야 애니메이션 프레임이 움직인다.  forceFlag 값은 true여야 동작에 문제가 없다.const state = useLocalObservable(  (): IState =&gt; ({    sequence: {      segments: initialSegments,      forceFlag: true,    },    setSequence(start: number, stop: number) {      state.sequence = {        segments: [start, stop],        forceFlag: true,      };      playSegments([start, stop], true);    },  }));Reference.https://betterprogramming.pub/how-to-use-manipulate-airbnbs-lottie-animations-in-react-6e63b94012cahttps://lottiereact.comhttps://github.com/Gamote/lottie-react",
            "content_html": "<p><br /></p><p>리액트에서 사용 가능한 <code class=\"language-plaintext highlighter-rouge\">lottie</code> 모듈 중 <code class=\"language-plaintext highlighter-rouge\">lottie-react</code> 를 사용하였다. <br />어떤 목적으로 사용하는지에 따라 다르겠지만 토글버튼을 사용하기 위해서 프레임 조정 기능을 지원하는 모듈이 필요했다.<br /><br /></p><h3 id=\"react-lottie\">react-lottie</h3><ul>  <li>playSegments를 내부적으로만 사용하기 때문에 <code class=\"language-plaintext highlighter-rouge\">forceFlag</code> 값을 따로 지정 못하는 문제점이 있었다.<br /><br />    <h3 id=\"react-lottie-segments\">react-lottie-segments</h3>  </li>  <li>playSegments를 간단하게 사용할 수 있었지만 지속적으로 관리되는 모듈을 사용하고자 하였다.<br /><br />    <h3 id=\"고려했던-부분들\">고려했던 부분들</h3>    <ol>      <li>클릭 이벤트 발생 시 프레임을 바꿔주려면 playSegments 메서드를 직접 호출해야 함</li>      <li>타입스크립트 지원이 되는 모듈</li>    </ol>  </li></ul><p><br /><br /></p><h3 id=\"playsegmentssegments-forceflag\">playSegments(segments, forceFlag)</h3><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">{</span><span class=\"nl\">segments</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"nx\">start</span><span class=\"p\">,</span> <span class=\"nx\">stop</span><span class=\"p\">],</span><span class=\"nx\">forceFlag</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"p\">}</span></code></pre></div></div><p><br /><strong>segments</strong><br />\tArray타입<br />\t첫번째, 두번째 인덱스에는 각각 시작 프레임과 정지프레임을 넣어준다. <code class=\"language-plaintext highlighter-rouge\">ex. [0, 1]</code> <br /><br /><strong>forceFlag</strong><br />\tBoolean 타입<br />\tfalse일 경우, 현재 세그먼트가 완료될 떄까지 기다린다. <br />\ttrue일 경우, 세그먼트 값을 바로 업데이트 한다. (인자를 true로 넘겨줘야 토글이 제대로 동작한다)<br /><br /></p><h4 id=\"프레임-지정\">프레임 지정</h4><ul>  <li>toggle 버튼이 시작점에서 ON -&gt; OFF -&gt; ON 순서에 따라 원점으로 돌아오는 동작을 기준으로 한다.</li>  <li>프레임의 초기값은 [0, 1] 로 넣어줘야 시작점에서 멈춰있는 상태로 대기하게 된다.</li>  <li>초기값을 [0, 0] 으로 지정할 경우 애니메이션이 루프를 한번 돌게 되므로 주의한다.</li>  <li>ON -&gt; OFF -&gt; ON 각각의 상태에 따라 프레임 설정을 아래와 같이 지정하였다.<br /><br /></li></ul><table>  <thead>    <tr>      <th>ON(멈춤)</th>      <th>ON → OFF(이동)</th>      <th>OFF(멈춤)</th>      <th>OFF → ON(이동)</th>    </tr>  </thead>  <tbody>    <tr>      <td>[0, 1]</td>      <td>[0, 전체프레임/2]</td>      <td>[전체프레임/2, 전체프레임/2 + 1]</td>      <td>[전체프레임/2, 전체프레임]</td>    </tr>  </tbody></table><p><br /><br /></p><h4 id=\"lottie-react\">lottie-React</h4><p>Componenet, Hook 2가지 타입으로 import해서 사용이 가능하다. 여기서는 Hook을 사용했다.<br /><br /></p><p><strong>👉 Hook의 사용</strong></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"kd\">const</span> <span class=\"nx\">style</span> <span class=\"o\">=</span> <span class=\"p\">{</span>    <span class=\"na\">height</span><span class=\"p\">:</span> <span class=\"mi\">36</span><span class=\"p\">,</span>    <span class=\"na\">width</span><span class=\"p\">:</span> <span class=\"mi\">60</span><span class=\"p\">,</span>  <span class=\"p\">};</span>  <span class=\"kd\">const</span> <span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"p\">{</span>    <span class=\"na\">loop</span><span class=\"p\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>    <span class=\"na\">autoplay</span><span class=\"p\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>    <span class=\"na\">animationData</span><span class=\"p\">:</span> <span class=\"nx\">jsonData</span><span class=\"p\">,</span>    <span class=\"na\">rendererSettings</span><span class=\"p\">:</span> <span class=\"p\">{</span>      <span class=\"na\">preserveAspectRatio</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">xMidYMid slice</span><span class=\"dl\">'</span><span class=\"p\">,</span>    <span class=\"p\">},</span>  <span class=\"p\">};</span><span class=\"kd\">const</span> <span class=\"p\">{</span> <span class=\"nx\">View</span><span class=\"p\">,</span> <span class=\"nx\">playSegments</span><span class=\"p\">,</span> <span class=\"nx\">setSpeed</span> <span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">useLottie</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">,</span> <span class=\"nx\">style</span><span class=\"p\">);</span></code></pre></div></div><p><br /><strong>👉 jsx 리턴</strong></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"cm\">/*   View의 형태는 아래와 같다. lottie-react github 참고    const View = &lt;div style={style} ref={animationContainer} {...rest} /&gt;;  */</span>    <span class=\"k\">return</span> <span class=\"p\">(</span>    <span class=\"o\">&lt;</span><span class=\"nx\">Wrapper</span>      <span class=\"nx\">onClick</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">onToggleHandler</span><span class=\"p\">}</span><span class=\"o\">&gt;</span>      <span class=\"p\">{</span><span class=\"nx\">View</span><span class=\"p\">}</span>    <span class=\"o\">&lt;</span><span class=\"sr\">/Wrapper</span><span class=\"err\">&gt;</span>  <span class=\"p\">);</span></code></pre></div></div><p><br /><br /></p><p><strong>👉 State 관리 및 playSegments의 사용</strong></p><ul>  <li>playSegments을 호출해야 애니메이션 프레임이 움직인다.</li>  <li>forceFlag 값은 true여야 동작에 문제가 없다.</li></ul><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">state</span> <span class=\"o\">=</span> <span class=\"nx\">useLocalObservable</span><span class=\"p\">(</span>  <span class=\"p\">():</span> <span class=\"nx\">IState</span> <span class=\"o\">=&gt;</span> <span class=\"p\">({</span>    <span class=\"na\">sequence</span><span class=\"p\">:</span> <span class=\"p\">{</span>      <span class=\"na\">segments</span><span class=\"p\">:</span> <span class=\"nx\">initialSegments</span><span class=\"p\">,</span>      <span class=\"na\">forceFlag</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>    <span class=\"p\">},</span>    <span class=\"nx\">setSequence</span><span class=\"p\">(</span><span class=\"na\">start</span><span class=\"p\">:</span> <span class=\"nx\">number</span><span class=\"p\">,</span> <span class=\"na\">stop</span><span class=\"p\">:</span> <span class=\"nx\">number</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">sequence</span> <span class=\"o\">=</span> <span class=\"p\">{</span>        <span class=\"na\">segments</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"nx\">start</span><span class=\"p\">,</span> <span class=\"nx\">stop</span><span class=\"p\">],</span>        <span class=\"na\">forceFlag</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>      <span class=\"p\">};</span>      <span class=\"nx\">playSegments</span><span class=\"p\">([</span><span class=\"nx\">start</span><span class=\"p\">,</span> <span class=\"nx\">stop</span><span class=\"p\">],</span> <span class=\"kc\">true</span><span class=\"p\">);</span>    <span class=\"p\">},</span>  <span class=\"p\">})</span><span class=\"p\">);</span></code></pre></div></div><p><br /><br /></p><h3 id=\"reference\">Reference.</h3><p><a href=\"https://betterprogramming.pub/how-to-use-manipulate-airbnbs-lottie-animations-in-react-6e63b94012ca\">https://betterprogramming.pub/how-to-use-manipulate-airbnbs-lottie-animations-in-react-6e63b94012ca</a><br /><a href=\"https://lottiereact.com\">https://lottiereact.com</a><br /><a href=\"https://github.com/Gamote/lottie-react\">https://github.com/Gamote/lottie-react</a><br /></p>",
            "url": "https://jheehg.github.io/2022/08/31/lottie-animation",
            
            
            
            "tags": ["react","lottie","animation","typescript"],
            
            "date_published": "2022-08-31T00:00:00+00:00",
            "date_modified": "2022-08-31T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2022/08/25/ts-exercise-10",
            "title": "Typescript Exercise 10 풀어보고 정리해보기",
            "summary": "Typescript Exercise 10 풀어보기",
            "content_text": "타입스크립트 학습을 위해 TypeScript exercises 문제를 풀어보고기억 보관 목적으로 정리해보는 글입니다. 😀 ➯ Exercise 10.데이터를 요청하는 함수를 재실행하지 않기 위해,기존의 코드 베이스로 Promise로 비동기 처리하는 함수를 생성해보기.최종적으로 결과가 성공하면 데이터를, 실패하면 에러메시지를 리턴하는 Promise 객체를 리턴하도록 해야한다.새로 만드는 함수의 이름은 promisify로 명명한다.+ 모든 요청을 object로 담고 이 요청들을 각각 promisify를 하도록 하는 함수 promisifyAll 를 만들어보기.아래 코드처럼 promisifyAll 가 리턴하는 객체를 api에 할당하기const api = promisifyAll(oldApi);타입 정의 및 사용 데이터User, Admin 각각의 인터페이스들은 유니온 타입(Union Type)을 사용해 Person이라는 타입을 생성한다. type은 공통 필드지만 제한값이 다르고 occupation은 User 인터페이스에, role은 Admin 인터페이스에만 정의되어 있다.interface User {    type: 'user';    name: string;    age: number;    occupation: string;}interface Admin {    type: 'admin';    name: string;    age: number;    role: string;}type Person = User | Admin;const admins: Admin[] = [    { type: 'admin', name: 'Jane Doe', age: 32, role: 'Administrator' },    { type: 'admin', name: 'Bruce Willis', age: 64, role: 'World saver' }];const users: User[] = [    { type: 'user', name: 'Max Mustermann', age: 25, occupation: 'Chimney sweep' },    { type: 'user', name: 'Kate Müller', age: 23, occupation: 'Astronaut' }];API 요청에 대한 응답결과를 정의하는 ApiResponse 를 타입으로 적용할때함수처럼 적용될 수 있도록 제네릭T 을 사용한다. 여기에 User[], Admin[] 또는 그 외에 값 또한 사용이 가능하다.export type ApiResponse&lt;T&gt; = (    {        status: 'success';        data: T;    } |    {        status: 'error';        error: string;    });oldApi 에 각 요청이 정의되어 있다. 각 요청함수의 인자로 callback 함수가 사용되는데 이를 ApiFunction 타입으로 정의한다.타입 정의할때, 제네릭을 사용해서 인자 타입인 ApiFunction에서도 또한 사용될 수 있도록 한다.type ApiFunction&lt;T&gt; = (callback: (response: ApiResponse&lt;T&gt;) =&gt; void) =&gt; void;const oldApi = {    requestAdmins(callback: (response: ApiResponse&lt;Admin[]&gt;) =&gt; void) {        callback({            status: 'success',            data: admins        });    },    requestUsers(callback: (response: ApiResponse&lt;User[]&gt;) =&gt; void) {        callback({            status: 'success',            data: users        });    },    requestCurrentServerTime(callback: (response: ApiResponse&lt;number&gt;) =&gt; void) {        callback({            status: 'success',            data: Date.now()        });    },    requestCoffeeMachineQueueLength(callback: (response: ApiResponse&lt;number&gt;) =&gt; void) {        callback({            status: 'error',            error: 'Numeric value has exceeded Number.MAX_SAFE_INTEGER.'        });    }};promisifyAll 함수는 각 요청함수를 담고있는 oldApi를 인자로 받아서 요청들을 promisify 하는 역할을 한다.export const api = promisifyAll(oldApi);promisify 함수는 ApiFunction 타입의 콜백함수를 인자로 받고 () =&gt; Promise 타입으로 리턴하게 된다. Promise객체 내부에서는 각 API 요청에 대한 결과를 처리하는 코드가 진행된다.type ReturnPromise&lt;T&gt; = () =&gt; Promise&lt;T&gt;;export function promisify&lt;T&gt;(arg: ApiFunction&lt;T&gt;): ReturnPromise&lt;T&gt; {    return () =&gt; new Promise&lt;T&gt;((resolve, reject) =&gt; {        arg((response) =&gt; {            if(response.status === 'success') {            resolve(response.data);            } else {                reject(new Error(response.error));            }        });    });}promisifyAll 함수는 각 요청의 콜백함수를 담은 object를 인자로 받고,그 object를 리턴하되 value 값은 각 요청에 대해서 promisify 함수를 호출한 결과를 담아 리턴한다.그 후에 object의 키값을 호출하면 API 응답결과를 사용할 수 있게 된다.type ApiObject&lt;T&gt; = {[K in keyof T]: ApiFunction&lt;T[K]&gt;};type PromiseResult&lt;T&gt; = {[K in keyof T]: ReturnPromise&lt;T[K]&gt;};export function promisifyAll&lt;T extends {[key: string]: any}&gt;(obj: ApiObject&lt;T&gt;): PromiseResult&lt;T&gt; {    let result:Partial&lt;PromiseResult&lt;T&gt;&gt; = {};    for(const requestApi of Object.keys(obj)) {        result[requestApi as keyof ApiObject&lt;T&gt;] = promisify(obj[requestApi]);    }    return result as PromiseResult&lt;T&gt;;}PromisifyAll 함수 좀 더 알아보기제네릭 타입으로 사용되는 T 의 형태를 아래와 같이 제한한다.&lt;T extends {[key: string]: any}&gt;처음에는 빈 객체가 기본값으로 할당되기 때문에 Partial 로 정의해주어야 오류가 나지 않는다.let result:Partial&lt;PromiseResult&lt;T&gt;&gt; = {};for .. of 에서 정의된 requestApi 은 string 타입이기 때문에 아래 result 객체의 키값으로 사용할 때다시 한번 ApiObject&lt;T&gt; 의 키 타입으로 형변환 해주어야 한다.for(const requestApi of Object.keys(obj)) {  result[requestApi as keyof ApiObject&lt;T&gt;] = promisify(obj[requestApi]);}ApiObject: `oldApi` 객체를 담는 타입PromiseResult: ApiObject와 key 값은 같지만 `Promisify` 호출 결과인 `() =&gt; Promise` 를 담는 타입promisifyAll 자체에서 T의 키인 K를 any타입으로 정의했기 때문에 ApiFunction&lt;any&gt; 가 되고,any 타입이기 때문에 promisify 내에서도 오류가 나지 않는 것 같다. (promisify에서는 User[], Admin[], number 로 지정해서 사용되었다.)이 부분이 제일 이해가 가지 않았는데 여기서 any 타입이 아닌 특정한 객체로 타입을 지정하게 되면 ApiFunction 사용할 때타입 오류가 나기 때문일까? any 타입 말고 다른 방법은 없을지 궁금하고 내가 추측한게 맞는지도 궁금하다. 🤔type ApiObject&lt;T&gt; = {[K in keyof T]: ApiFunction&lt;T[K]&gt;};type PromiseResult&lt;T&gt; = {[K in keyof T]: ReturnPromise&lt;T[K]&gt;};아래 코드는 promisify된 요청들에 대한 응답을 사용하는 함수들이다.function logPerson(person: Person) {    console.log(        ` - ${person.name}, ${person.age}, ${person.type === 'admin' ? person.role : person.occupation}`    );}async function startTheApp() {    console.log('Admins:');    (await api.requestAdmins()).forEach(logPerson);    console.log();    console.log('Users:');    (await api.requestUsers()).forEach(logPerson);    console.log();    console.log('Server time:');    console.log(`   ${new Date(await api.requestCurrentServerTime()).toLocaleString()}`);    console.log();    console.log('Coffee machine queue length:');    console.log(`   ${await api.requestCoffeeMachineQueueLength()}`);}startTheApp().then(    () =&gt; {        console.log('Success!');    },    (e: Error) =&gt; {        console.log(`Error: \"${e.message}\", but it's fine, sometimes errors are inevitable.`);    });모든 소스는 아래 링크에서 참고하였습니다https://typescript-exercises.github.io/#exercise=10&amp;file=%2Findex.ts",
            "content_html": "<p><br />타입스크립트 학습을 위해 TypeScript exercises 문제를 풀어보고기억 보관 목적으로 정리해보는 글입니다. 😀 <br /><br /><br /></p><h3 id=\"-exercise-10\">➯ Exercise 10.</h3><p>데이터를 요청하는 함수를 재실행하지 않기 위해,<br />기존의 코드 베이스로 Promise로 비동기 처리하는 함수를 생성해보기.<br />최종적으로 결과가 성공하면 데이터를, 실패하면 에러메시지를 리턴하는 <code class=\"language-plaintext highlighter-rouge\">Promise</code> 객체를 리턴하도록 해야한다.<br />새로 만드는 함수의 이름은 <code class=\"language-plaintext highlighter-rouge\">promisify</code>로 명명한다.<br />+ <br />모든 요청을 object로 담고 이 요청들을 각각 promisify를 하도록 하는 함수 <code class=\"language-plaintext highlighter-rouge\">promisifyAll</code> 를 만들어보기.<br />아래 코드처럼 <code class=\"language-plaintext highlighter-rouge\">promisifyAll</code> 가 리턴하는 객체를 api에 할당하기<br /></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">api</span> <span class=\"o\">=</span> <span class=\"nx\">promisifyAll</span><span class=\"p\">(</span><span class=\"nx\">oldApi</span><span class=\"p\">);</span></code></pre></div></div><p><br /><br /></p><h3 id=\"타입-정의-및-사용-데이터\">타입 정의 및 사용 데이터</h3><p><code class=\"language-plaintext highlighter-rouge\">User</code>, <code class=\"language-plaintext highlighter-rouge\">Admin</code> 각각의 인터페이스들은 유니온 타입(<code class=\"language-plaintext highlighter-rouge\">Union Type</code>)을 사용해 <code class=\"language-plaintext highlighter-rouge\">Person</code>이라는 타입을 생성한다. <br />type은 공통 필드지만 제한값이 다르고 <code class=\"language-plaintext highlighter-rouge\">occupation</code>은 User 인터페이스에, <code class=\"language-plaintext highlighter-rouge\">role</code>은 Admin 인터페이스에만 정의되어 있다.<br /></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kr\">interface</span> <span class=\"nx\">User</span> <span class=\"p\">{</span>    <span class=\"nl\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">user</span><span class=\"dl\">'</span><span class=\"p\">;</span>    <span class=\"nl\">name</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>    <span class=\"nl\">age</span><span class=\"p\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>    <span class=\"nl\">occupation</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"kr\">interface</span> <span class=\"nx\">Admin</span> <span class=\"p\">{</span>    <span class=\"nl\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">admin</span><span class=\"dl\">'</span><span class=\"p\">;</span>    <span class=\"nl\">name</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>    <span class=\"nl\">age</span><span class=\"p\">:</span> <span class=\"nx\">number</span><span class=\"p\">;</span>    <span class=\"nl\">role</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span><span class=\"p\">}</span><span class=\"nx\">type</span> <span class=\"nx\">Person</span> <span class=\"o\">=</span> <span class=\"nx\">User</span> <span class=\"o\">|</span> <span class=\"nx\">Admin</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">admins</span><span class=\"p\">:</span> <span class=\"nx\">Admin</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">[</span>    <span class=\"p\">{</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">admin</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Jane Doe</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">age</span><span class=\"p\">:</span> <span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"na\">role</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Administrator</span><span class=\"dl\">'</span> <span class=\"p\">},</span>    <span class=\"p\">{</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">admin</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Bruce Willis</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">age</span><span class=\"p\">:</span> <span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"na\">role</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">World saver</span><span class=\"dl\">'</span> <span class=\"p\">}</span><span class=\"p\">];</span><span class=\"kd\">const</span> <span class=\"nx\">users</span><span class=\"p\">:</span> <span class=\"nx\">User</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"p\">[</span>    <span class=\"p\">{</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">user</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Max Mustermann</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">age</span><span class=\"p\">:</span> <span class=\"mi\">25</span><span class=\"p\">,</span> <span class=\"na\">occupation</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Chimney sweep</span><span class=\"dl\">'</span> <span class=\"p\">},</span>    <span class=\"p\">{</span> <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">user</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Kate Müller</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">age</span><span class=\"p\">:</span> <span class=\"mi\">23</span><span class=\"p\">,</span> <span class=\"na\">occupation</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Astronaut</span><span class=\"dl\">'</span> <span class=\"p\">}</span><span class=\"p\">];</span></code></pre></div></div><p><br /><br />API 요청에 대한 응답결과를 정의하는 <code class=\"language-plaintext highlighter-rouge\">ApiResponse</code> 를 타입으로 적용할때<br />함수처럼 적용될 수 있도록 제네릭<code class=\"language-plaintext highlighter-rouge\">T</code> 을 사용한다. 여기에 <code class=\"language-plaintext highlighter-rouge\">User[]</code>, <code class=\"language-plaintext highlighter-rouge\">Admin[]</code> 또는 그 외에 값 또한 사용이 가능하다.<br /></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">export</span> <span class=\"nx\">type</span> <span class=\"nx\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">(</span>    <span class=\"p\">{</span>        <span class=\"na\">status</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">success</span><span class=\"dl\">'</span><span class=\"p\">;</span>        <span class=\"nl\">data</span><span class=\"p\">:</span> <span class=\"nx\">T</span><span class=\"p\">;</span>    <span class=\"p\">}</span> <span class=\"o\">|</span>    <span class=\"p\">{</span>        <span class=\"na\">status</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">error</span><span class=\"dl\">'</span><span class=\"p\">;</span>        <span class=\"nl\">error</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">;</span>    <span class=\"p\">}</span><span class=\"p\">);</span></code></pre></div></div><p><br /><br /><code class=\"language-plaintext highlighter-rouge\">oldApi</code> 에 각 요청이 정의되어 있다. 각 요청함수의 인자로 callback 함수가 사용되는데 이를 <code class=\"language-plaintext highlighter-rouge\">ApiFunction</code> 타입으로 <br />정의한다.타입 정의할때, 제네릭을 사용해서 인자 타입인 <code class=\"language-plaintext highlighter-rouge\">ApiFunction</code>에서도 또한 사용될 수 있도록 한다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">type</span> <span class=\"nx\">ApiFunction</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">callback</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">:</span> <span class=\"nx\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">void</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">void</span><span class=\"p\">;</span><span class=\"kd\">const</span> <span class=\"nx\">oldApi</span> <span class=\"o\">=</span> <span class=\"p\">{</span>    <span class=\"nx\">requestAdmins</span><span class=\"p\">(</span><span class=\"na\">callback</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"na\">response</span><span class=\"p\">:</span> <span class=\"nx\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nx\">Admin</span><span class=\"p\">[]</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">void</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"nx\">callback</span><span class=\"p\">({</span>            <span class=\"na\">status</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">success</span><span class=\"dl\">'</span><span class=\"p\">,</span>            <span class=\"na\">data</span><span class=\"p\">:</span> <span class=\"nx\">admins</span>        <span class=\"p\">});</span>    <span class=\"p\">},</span>    <span class=\"nx\">requestUsers</span><span class=\"p\">(</span><span class=\"na\">callback</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"na\">response</span><span class=\"p\">:</span> <span class=\"nx\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nx\">User</span><span class=\"p\">[]</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">void</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"nx\">callback</span><span class=\"p\">({</span>            <span class=\"na\">status</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">success</span><span class=\"dl\">'</span><span class=\"p\">,</span>            <span class=\"na\">data</span><span class=\"p\">:</span> <span class=\"nx\">users</span>        <span class=\"p\">});</span>    <span class=\"p\">},</span>    <span class=\"nx\">requestCurrentServerTime</span><span class=\"p\">(</span><span class=\"na\">callback</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"na\">response</span><span class=\"p\">:</span> <span class=\"nx\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nx\">number</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">void</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"nx\">callback</span><span class=\"p\">({</span>            <span class=\"na\">status</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">success</span><span class=\"dl\">'</span><span class=\"p\">,</span>            <span class=\"na\">data</span><span class=\"p\">:</span> <span class=\"nb\">Date</span><span class=\"p\">.</span><span class=\"nx\">now</span><span class=\"p\">()</span>        <span class=\"p\">});</span>    <span class=\"p\">},</span>    <span class=\"nx\">requestCoffeeMachineQueueLength</span><span class=\"p\">(</span><span class=\"na\">callback</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"na\">response</span><span class=\"p\">:</span> <span class=\"nx\">ApiResponse</span><span class=\"o\">&lt;</span><span class=\"nx\">number</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"k\">void</span><span class=\"p\">)</span> <span class=\"p\">{</span>        <span class=\"nx\">callback</span><span class=\"p\">({</span>            <span class=\"na\">status</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">error</span><span class=\"dl\">'</span><span class=\"p\">,</span>            <span class=\"na\">error</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Numeric value has exceeded Number.MAX_SAFE_INTEGER.</span><span class=\"dl\">'</span>        <span class=\"p\">});</span>    <span class=\"p\">}</span><span class=\"p\">};</span></code></pre></div></div><p><br /><br /><code class=\"language-plaintext highlighter-rouge\">promisifyAll</code> 함수는 각 요청함수를 담고있는 <code class=\"language-plaintext highlighter-rouge\">oldApi</code>를 인자로 받아서 요청들을 <code class=\"language-plaintext highlighter-rouge\">promisify</code> 하는 역할을 한다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">export</span> <span class=\"kd\">const</span> <span class=\"nx\">api</span> <span class=\"o\">=</span> <span class=\"nx\">promisifyAll</span><span class=\"p\">(</span><span class=\"nx\">oldApi</span><span class=\"p\">);</span></code></pre></div></div><p><br /><br /></p><p><code class=\"language-plaintext highlighter-rouge\">promisify</code> 함수는 <code class=\"language-plaintext highlighter-rouge\">ApiFunction</code> 타입의 콜백함수를 인자로 받고 <code class=\"language-plaintext highlighter-rouge\">() =&gt; Promise</code> 타입으로 리턴하게 된다. <br />Promise객체 내부에서는 각 API 요청에 대한 결과를 처리하는 코드가 진행된다.<br /></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">type</span> <span class=\"nx\">ReturnPromise</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"nb\">Promise</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">promisify</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">arg</span><span class=\"p\">:</span> <span class=\"nx\">ApiFunction</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">):</span> <span class=\"nx\">ReturnPromise</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>    <span class=\"k\">return</span> <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"k\">new</span> <span class=\"nb\">Promise</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">((</span><span class=\"nx\">resolve</span><span class=\"p\">,</span> <span class=\"nx\">reject</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>        <span class=\"nx\">arg</span><span class=\"p\">((</span><span class=\"nx\">response</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>            <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">status</span> <span class=\"o\">===</span> <span class=\"dl\">'</span><span class=\"s1\">success</span><span class=\"dl\">'</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">);</span>            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>                <span class=\"nx\">reject</span><span class=\"p\">(</span><span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"nx\">response</span><span class=\"p\">.</span><span class=\"nx\">error</span><span class=\"p\">));</span>            <span class=\"p\">}</span>        <span class=\"p\">});</span>    <span class=\"p\">});</span><span class=\"p\">}</span></code></pre></div></div><p><br /><br /></p><p><code class=\"language-plaintext highlighter-rouge\">promisifyAll</code> 함수는 각 요청의 콜백함수를 담은 object를 인자로 받고,<br />그 object를 리턴하되 value 값은 각 요청에 대해서 promisify 함수를 호출한 결과를 담아 리턴한다.<br />그 후에 object의 키값을 호출하면 API 응답결과를 사용할 수 있게 된다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nx\">type</span> <span class=\"nx\">ApiObject</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">{[</span><span class=\"nx\">K</span> <span class=\"k\">in</span> <span class=\"nx\">keyof</span> <span class=\"nx\">T</span><span class=\"p\">]:</span> <span class=\"nx\">ApiFunction</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"p\">[</span><span class=\"nx\">K</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">};</span><span class=\"nx\">type</span> <span class=\"nx\">PromiseResult</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">{[</span><span class=\"nx\">K</span> <span class=\"k\">in</span> <span class=\"nx\">keyof</span> <span class=\"nx\">T</span><span class=\"p\">]:</span> <span class=\"nx\">ReturnPromise</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"p\">[</span><span class=\"nx\">K</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">};</span><span class=\"k\">export</span> <span class=\"kd\">function</span> <span class=\"nx\">promisifyAll</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span> <span class=\"kd\">extends</span> <span class=\"p\">{[</span><span class=\"na\">key</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">]:</span> <span class=\"nx\">any</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nx\">obj</span><span class=\"p\">:</span> <span class=\"nx\">ApiObject</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">):</span> <span class=\"nx\">PromiseResult</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>    <span class=\"kd\">let</span> <span class=\"na\">result</span><span class=\"p\">:</span><span class=\"nx\">Partial</span><span class=\"o\">&lt;</span><span class=\"nx\">PromiseResult</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">const</span> <span class=\"nx\">requestApi</span> <span class=\"k\">of</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"nx\">obj</span><span class=\"p\">))</span> <span class=\"p\">{</span>        <span class=\"nx\">result</span><span class=\"p\">[</span><span class=\"nx\">requestApi</span> <span class=\"k\">as</span> <span class=\"nx\">keyof</span> <span class=\"nx\">ApiObject</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">promisify</span><span class=\"p\">(</span><span class=\"nx\">obj</span><span class=\"p\">[</span><span class=\"nx\">requestApi</span><span class=\"p\">]);</span>    <span class=\"p\">}</span>    <span class=\"k\">return</span> <span class=\"nx\">result</span> <span class=\"k\">as</span> <span class=\"nx\">PromiseResult</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"p\">}</span></code></pre></div></div><p><br /><br /></p><h3 id=\"promisifyall-함수-좀-더-알아보기\">PromisifyAll 함수 좀 더 알아보기</h3><p>제네릭 타입으로 사용되는 <code class=\"language-plaintext highlighter-rouge\">T</code> 의 형태를 아래와 같이 제한한다.<br /></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">&lt;</span><span class=\"nx\">T</span> <span class=\"kd\">extends</span> <span class=\"p\">{[</span><span class=\"na\">key</span><span class=\"p\">:</span> <span class=\"nx\">string</span><span class=\"p\">]:</span> <span class=\"nx\">any</span><span class=\"p\">}</span><span class=\"o\">&gt;</span></code></pre></div></div><p><br />처음에는 빈 객체가 기본값으로 할당되기 때문에 <u>Partial</u> 로 정의해주어야 오류가 나지 않는다.<br /></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">let</span> <span class=\"nx\">result</span><span class=\"p\">:</span><span class=\"nx\">Partial</span><span class=\"o\">&lt;</span><span class=\"nx\">PromiseResult</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"o\">=</span> <span class=\"p\">{};</span></code></pre></div></div><p><br /><br /></p><p><code class=\"language-plaintext highlighter-rouge\">for .. of</code> 에서 정의된 <code class=\"language-plaintext highlighter-rouge\">requestApi</code> 은 <code class=\"language-plaintext highlighter-rouge\">string</code> 타입이기 때문에 아래 <code class=\"language-plaintext highlighter-rouge\">result</code> 객체의 키값으로 사용할 때<br />다시 한번 <code class=\"language-plaintext highlighter-rouge\">ApiObject&lt;T&gt;</code> 의 키 타입으로 형변환 해주어야 한다.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">const</span> <span class=\"nx\">requestApi</span> <span class=\"k\">of</span> <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"nx\">obj</span><span class=\"p\">))</span> <span class=\"p\">{</span>  <span class=\"nx\">result</span><span class=\"p\">[</span><span class=\"nx\">requestApi</span> <span class=\"k\">as</span> <span class=\"nx\">keyof</span> <span class=\"nx\">ApiObject</span><span class=\"o\">&lt;</span><span class=\"nx\">T</span><span class=\"o\">&gt;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">promisify</span><span class=\"p\">(</span><span class=\"nx\">obj</span><span class=\"p\">[</span><span class=\"nx\">requestApi</span><span class=\"p\">]);</span><span class=\"p\">}</span></code></pre></div></div><p><br /><br /><u>ApiObject: `oldApi` 객체를 담는 타입</u><br /><u>PromiseResult: ApiObject와 key 값은 같지만 `Promisify` 호출 결과인 `() =&gt; Promise` 를 담는 타입</u><br /></p><p><code class=\"language-plaintext highlighter-rouge\">promisifyAll</code> 자체에서 T의 키인 K를 <code class=\"language-plaintext highlighter-rouge\">any</code>타입으로 정의했기 때문에 <code class=\"language-plaintext highlighter-rouge\">ApiFunction&lt;any&gt;</code> 가 되고,<br /><code class=\"language-plaintext highlighter-rouge\">any</code> 타입이기 때문에 promisify 내에서도 오류가 나지 않는 것 같다. <br />(promisify에서는 User[], Admin[], number 로 지정해서 사용되었다.)<br />이 부분이 제일 이해가 가지 않았는데 여기서 <code class=\"language-plaintext highlighter-rouge\">any</code> 타입이 아닌 특정한 객체로 타입을 지정하게 되면<br /> ApiFunction 사용할 때타입 오류가 나기 때문일까?<br /> <code class=\"language-plaintext highlighter-rouge\">any</code> 타입 말고 다른 방법은 없을지 궁금하고 내가 추측한게 맞는지도 궁금하다. 🤔</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type ApiObject&lt;T&gt; = {[K in keyof T]: ApiFunction&lt;T[K]&gt;};type PromiseResult&lt;T&gt; = {[K in keyof T]: ReturnPromise&lt;T[K]&gt;};</code></pre></div></div><p><br /><br /><br />아래 코드는 promisify된 요청들에 대한 응답을 사용하는 함수들이다.<br /></p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">function</span> <span class=\"nx\">logPerson</span><span class=\"p\">(</span><span class=\"nx\">person</span><span class=\"p\">:</span> <span class=\"nx\">Person</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span>        <span class=\"s2\">` - </span><span class=\"p\">${</span><span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">}</span><span class=\"s2\">, </span><span class=\"p\">${</span><span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">age</span><span class=\"p\">}</span><span class=\"s2\">, </span><span class=\"p\">${</span><span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">type</span> <span class=\"o\">===</span> <span class=\"dl\">'</span><span class=\"s1\">admin</span><span class=\"dl\">'</span> <span class=\"p\">?</span> <span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">role</span> <span class=\"p\">:</span> <span class=\"nx\">person</span><span class=\"p\">.</span><span class=\"nx\">occupation</span><span class=\"p\">}</span><span class=\"s2\">`</span>    <span class=\"p\">);</span><span class=\"p\">}</span><span class=\"k\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">startTheApp</span><span class=\"p\">()</span> <span class=\"p\">{</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Admins:</span><span class=\"dl\">'</span><span class=\"p\">);</span>    <span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"nx\">api</span><span class=\"p\">.</span><span class=\"nx\">requestAdmins</span><span class=\"p\">()).</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">logPerson</span><span class=\"p\">);</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Users:</span><span class=\"dl\">'</span><span class=\"p\">);</span>    <span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"nx\">api</span><span class=\"p\">.</span><span class=\"nx\">requestUsers</span><span class=\"p\">()).</span><span class=\"nx\">forEach</span><span class=\"p\">(</span><span class=\"nx\">logPerson</span><span class=\"p\">);</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Server time:</span><span class=\"dl\">'</span><span class=\"p\">);</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`   </span><span class=\"p\">${</span><span class=\"k\">new</span> <span class=\"nb\">Date</span><span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"nx\">api</span><span class=\"p\">.</span><span class=\"nx\">requestCurrentServerTime</span><span class=\"p\">()).</span><span class=\"nx\">toLocaleString</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">();</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Coffee machine queue length:</span><span class=\"dl\">'</span><span class=\"p\">);</span>    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`   </span><span class=\"p\">${</span><span class=\"k\">await</span> <span class=\"nx\">api</span><span class=\"p\">.</span><span class=\"nx\">requestCoffeeMachineQueueLength</span><span class=\"p\">()}</span><span class=\"s2\">`</span><span class=\"p\">);</span><span class=\"p\">}</span><span class=\"nx\">startTheApp</span><span class=\"p\">().</span><span class=\"nx\">then</span><span class=\"p\">(</span>    <span class=\"p\">()</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">Success!</span><span class=\"dl\">'</span><span class=\"p\">);</span>    <span class=\"p\">},</span>    <span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">:</span> <span class=\"nb\">Error</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">`Error: \"</span><span class=\"p\">${</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">message</span><span class=\"p\">}</span><span class=\"s2\">\", but it's fine, sometimes errors are inevitable.`</span><span class=\"p\">);</span>    <span class=\"p\">}</span><span class=\"p\">);</span></code></pre></div></div><p><br /><br /><br /><br /></p><p><b>모든 소스는 아래 링크에서 참고하였습니다</b><br /><a href=\"https://typescript-exercises.github.io/#exercise=10&amp;file=%2Findex.ts\">https://typescript-exercises.github.io/#exercise=10&amp;file=%2Findex.ts</a></p>",
            "url": "https://jheehg.github.io/2022/08/25/ts-exercise-10",
            
            
            
            
            
            "date_published": "2022-08-25T00:00:00+00:00",
            "date_modified": "2022-08-25T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2022/08/15/deploy-with-github-actions",
            "title": "github actions으로 jekyll 수동 배포",
            "summary": "github actions으로 jekyll 수동 배포를 위한 글입니다.",
            "content_text": "github actions로 배포하게 된 이유jekyll 에서는 카테고리나 태그 같은 기능을 사용자가 직접 플러그인을 생성해서 사용할 수 있게 하는데 github-pages 로 자동 배포하게 될 경우 커스텀 플러그인을 사용할 수 없게 된다.아래 jekyll 공식 docs에서 github actions과 plugin에 관련된 설명이다.When building a Jekyll site with GitHub Pages, the standard flow is restricted for securityreasons and to make it simpler to get a site setup. For more control over the build and still host the site with GitHub Pages you can use GitHub Actions.Plugins — You can use any Jekyll plugins irrespective of them being on the supportedversions list, even *.rb files placed in the _plugins directory of your site.이로 인해 category 플러그인 생성 후 실제 배포를 하면 /tag/*, /category/* 가404 not found 페이지로 이동했다. (아래와 같이 _plugins  에서 tags는 가져왔던 테마에 원래 있었고 category는 새로 생성한 상태였다.)구글링을 통해 현재 상태에서 해결할 수 있는 방법을 찾았으나 실패했다.master 브랜치에 .nojekyll 파일을 _site 폴더와 같이 커밋해서 배포하는 방법..?github actions에서 새 workflow 생성workflow 파일의 경우 github actions 에서 제공하는 것도 있고 marketplace에서 찾을 수도 있는데나는 아래 github에 예시와 jekyll을 수동 배포한 다른 블로그 글들을 보고 참고해서 작성했다.https://github.com/helaili/jekyll-actionworkflow 배포하면서 실패했던 원인들을 정리해보기name: Build and deploy Jekyll site to GitHub Pageson:  push:    branches:      - masterjobs:  github-pages:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - uses: actions/cache@v2        with:          path: vendor/bundle          key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile') }}          restore-keys: |            ${{ runner.os }}-gems-      - uses: helaili/jekyll-action@2.0.5    # Choose any one of the Jekyll Actions        with:          target_branch: 'gh-pages'        env:                                # Some relative inputs of your action          JEKYLL_PAT: ${{ secrets.JEKYLL_PAT }}🔗 target_branch 를 gh_pages 로 지정해주어야 _site 디렉토리 안에 정적파일들이 해당 브런치에 생성된다.🔗 workflow에 secrtes 지정할 때 key, value값 주의하기PAT 추가해주는 부분에 key값을 어떻게 입력해야 될지 확실하지 않아서 이 부분에서 여러번 배포를 실패했다. PAT 키 생성과 input입력은 아래 과정과 같이 해결했다.       레파지토리에서 settings 탭으로 이동한다.        Security 탭에서 Action 탭으로 이동한다.        Repository secrets에 토큰 값을 추가해준다. 이 토큰 값은 github 개인 설정 페이지에서 Developer settings - Personal access tokens 에서 생성 해준 값을 사용한다.        workflow file에 Repository secrets input으로 key값과 value값은 각각  JEKYLL_PAT, ${{ secrets.JEKYLL_PAT }} 으로 넣어준다. secrets 명은 임의로 생성한다.  아래는 github actions workflow security guide 관련 문서인데 secrets 생성하는 규칙이 나와있다. https://docs.github.com/en/actions/security-guides/encrypted-secrets 🔗 배포 소스 파일의 브랜치 설정을 gh-pages 로 지정하기      레파지토리의 settings 탭에서 Pages 페이지로 이동한다.        Build and deployment 에서 branch 지정을 master에서 gh-pages로 변경해준다.  아래 블로그 글에 해당 내용이 잘 나와 있다.https://bitbra.in/2021/10/03/host-your-own-blog-for-free-with-custom-domain.html추가로 더 알아봐야 할 내용들github-pages에서 자동배포 되는 action이 수동으로 생성한 action과 중복해서 실행되고 있는데 수동으로 생성한 workflow만 실행되게 할 수 있을지 알아보려고 한다.github actions 참고 자료https://docs.github.com/en/actionshttps://jekyllrb.com/docs/continuous-integration/github-actions/#advantages-of-using-actions",
            "content_html": "<p><br /></p><h3 id=\"github-actions로-배포하게-된-이유\">github actions로 배포하게 된 이유</h3><hr /><p>jekyll 에서는 카테고리나 태그 같은 기능을 사용자가 직접 플러그인을 생성해서 사용할 수 있게 하는데 <br /><code class=\"language-plaintext highlighter-rouge\">github-pages</code> 로 자동 배포하게 될 경우 커스텀 플러그인을 사용할 수 없게 된다.<br /></p><p>아래 jekyll 공식 docs에서 github actions과 plugin에 관련된 설명이다.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>When building a Jekyll site with GitHub Pages, the standard flow is restricted for securityreasons and to make it simpler to get a site setup. For more control over the build and still host the site with GitHub Pages you can use GitHub Actions.Plugins — You can use any Jekyll plugins irrespective of them being on the supportedversions list, even *.rb files placed in the _plugins directory of your site.</code></pre></div></div><p><br />이로 인해 <code class=\"language-plaintext highlighter-rouge\">category</code> 플러그인 생성 후 실제 배포를 하면 <code class=\"language-plaintext highlighter-rouge\">/tag/*</code>, <code class=\"language-plaintext highlighter-rouge\">/category/*</code> 가<code class=\"language-plaintext highlighter-rouge\">404 not found</code> 페이지로 이동했다. <br />(아래와 같이 <code class=\"language-plaintext highlighter-rouge\">_plugins</code>  에서 tags는 가져왔던 테마에 원래 있었고 category는 새로 생성한 상태였다.)</p><p><img width=\"300\" alt=\"jekyll_plugins\" src=\"https://user-images.githubusercontent.com/56527636/184523048-6270d2f0-7fa6-4a9d-b4ca-1ea062f06c8f.png\" /></p><p>구글링을 통해 현재 상태에서 해결할 수 있는 방법을 찾았으나 실패했다.</p><s>master 브랜치에 .nojekyll 파일을 _site 폴더와 같이 커밋해서 배포하는 방법..?</s><p><br /><br /></p><h3 id=\"github-actions에서-새-workflow-생성\">github actions에서 새 workflow 생성</h3><hr /><p>workflow 파일의 경우 github actions 에서 제공하는 것도 있고 marketplace에서 찾을 수도 있는데<br />나는 아래 github에 예시와 jekyll을 수동 배포한 다른 블로그 글들을 보고 참고해서 작성했다.<br /><a href=\"https://github.com/helaili/jekyll-action\">https://github.com/helaili/jekyll-action</a></p><p><br /></p><h3 id=\"workflow-배포하면서-실패했던-원인들을-정리해보기\">workflow 배포하면서 실패했던 원인들을 정리해보기</h3><div class=\"language-yml highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"na\">name</span><span class=\"pi\">:</span> <span class=\"s\">Build and deploy Jekyll site to GitHub Pages</span><span class=\"na\">on</span><span class=\"pi\">:</span>  <span class=\"na\">push</span><span class=\"pi\">:</span>    <span class=\"na\">branches</span><span class=\"pi\">:</span>      <span class=\"pi\">-</span> <span class=\"s\">master</span><span class=\"na\">jobs</span><span class=\"pi\">:</span>  <span class=\"na\">github-pages</span><span class=\"pi\">:</span>    <span class=\"na\">runs-on</span><span class=\"pi\">:</span> <span class=\"s\">ubuntu-latest</span>    <span class=\"na\">steps</span><span class=\"pi\">:</span>      <span class=\"pi\">-</span> <span class=\"na\">uses</span><span class=\"pi\">:</span> <span class=\"s\">actions/checkout@v2</span>      <span class=\"pi\">-</span> <span class=\"na\">uses</span><span class=\"pi\">:</span> <span class=\"s\">actions/cache@v2</span>        <span class=\"na\">with</span><span class=\"pi\">:</span>          <span class=\"na\">path</span><span class=\"pi\">:</span> <span class=\"s\">vendor/bundle</span>          <span class=\"na\">key</span><span class=\"pi\">:</span> <span class=\"s\">${{ runner.os }}-gems-${{ hashFiles('**/Gemfile') }}</span>          <span class=\"na\">restore-keys</span><span class=\"pi\">:</span> <span class=\"pi\">|</span>            <span class=\"s\">${{ runner.os }}-gems-</span>      <span class=\"pi\">-</span> <span class=\"na\">uses</span><span class=\"pi\">:</span> <span class=\"s\">helaili/jekyll-action@2.0.5</span>    <span class=\"c1\"># Choose any one of the Jekyll Actions</span>        <span class=\"na\">with</span><span class=\"pi\">:</span>          <span class=\"na\">target_branch</span><span class=\"pi\">:</span> <span class=\"s1\">'</span><span class=\"s\">gh-pages'</span>        <span class=\"na\">env</span><span class=\"pi\">:</span>                                <span class=\"c1\"># Some relative inputs of your action</span>          <span class=\"na\">JEKYLL_PAT</span><span class=\"pi\">:</span> <span class=\"s\">${{ secrets.JEKYLL_PAT }}</span></code></pre></div></div><p><br /></p><h4 id=\"-target_branch-를-gh_pages-로-지정해주어야-_site-디렉토리-안에-정적파일들이-해당-브런치에-생성된다\">🔗 target_branch 를 <code class=\"language-plaintext highlighter-rouge\">gh_pages</code> 로 지정해주어야 <code class=\"language-plaintext highlighter-rouge\">_site</code> 디렉토리 안에 정적파일들이 해당 브런치에 생성된다.</h4><h4 id=\"-workflow에-secrtes-지정할-때-key-value값-주의하기\">🔗 workflow에 secrtes 지정할 때 key, value값 주의하기</h4><p>PAT 추가해주는 부분에 key값을 어떻게 입력해야 될지 확실하지 않아서 이 부분에서 여러번 배포를 실패했다. <br />PAT 키 생성과 input입력은 아래 과정과 같이 해결했다. <br /><br /></p><ul>  <li>    <p>레파지토리에서 settings 탭으로 이동한다.<br /><br /><img width=\"800\" alt=\"repo_settings\" src=\"https://user-images.githubusercontent.com/56527636/184523331-a61d8264-1077-4ebc-8e21-0546c6102fb4.png\" /><br /><br /><br /></p>  </li>  <li>    <p>Security 탭에서 Action 탭으로 이동한다.<br /><br /><img width=\"280\" alt=\"security_page\" src=\"https://user-images.githubusercontent.com/56527636/184523358-986607ad-31e0-4a2e-9c9f-62421d5276ab.png\" /><br /><br /><br /></p>  </li>  <li>    <p>Repository secrets에 토큰 값을 추가해준다. <br />이 토큰 값은 github 개인 설정 페이지에서 Developer settings - Personal access tokens 에서 생성 해준 값을 사용한다.<br /><br /><img width=\"650\" alt=\"repo_secrets\" src=\"https://user-images.githubusercontent.com/56527636/184523439-19ee3b91-c157-475b-a4b3-ded07d11d55a.png\" /><br /><br /><br /></p>  </li>  <li>    <p>workflow file에 Repository secrets input으로 key값과 value값은 각각 <br /> <code class=\"language-plaintext highlighter-rouge\">JEKYLL_PAT</code>, <code class=\"language-plaintext highlighter-rouge\">${{ secrets.JEKYLL_PAT }}</code> 으로 넣어준다. secrets 명은 임의로 생성한다.<br /></p>  </li></ul><p>아래는 github actions workflow security guide 관련 문서인데 secrets 생성하는 규칙이 나와있다. <br /><a href=\"https://docs.github.com/en/actions/security-guides/encrypted-secrets\">https://docs.github.com/en/actions/security-guides/encrypted-secrets</a> <br /><br /><br /><br /></p><h4 id=\"-배포-소스-파일의-브랜치-설정을-gh-pages-로-지정하기\">🔗 배포 소스 파일의 브랜치 설정을 <code class=\"language-plaintext highlighter-rouge\">gh-pages</code> 로 지정하기</h4><ul>  <li>    <p>레파지토리의 settings 탭에서 <code class=\"language-plaintext highlighter-rouge\">Pages</code> 페이지로 이동한다.<br /><br /><img width=\"280\" alt=\"pages\" src=\"https://user-images.githubusercontent.com/56527636/184597903-ff99a5f1-3fea-4329-ace1-b87f86fba142.png\" /><br /><br /><br /></p>  </li>  <li>    <p>Build and deployment 에서 branch 지정을 <code class=\"language-plaintext highlighter-rouge\">master</code>에서 <code class=\"language-plaintext highlighter-rouge\">gh-pages</code>로 변경해준다.<br /><br /><img width=\"700\" alt=\"build-branch\" src=\"https://user-images.githubusercontent.com/56527636/184597964-1aa61cd3-434c-464f-83ed-d247b4e595fa.png\" /><br /></p>  </li></ul><p>아래 블로그 글에 해당 내용이 잘 나와 있다.<br /><a href=\"https://bitbra.in/2021/10/03/host-your-own-blog-for-free-with-custom-domain.html\">https://bitbra.in/2021/10/03/host-your-own-blog-for-free-with-custom-domain.html</a><br /><br /></p><h3 id=\"추가로-더-알아봐야-할-내용들\">추가로 더 알아봐야 할 내용들</h3><p><code class=\"language-plaintext highlighter-rouge\">github-pages</code>에서 자동배포 되는 action이 수동으로 생성한 action과 중복해서 실행되고 있는데 <br />수동으로 생성한 workflow만 실행되게 할 수 있을지 알아보려고 한다.</p><p><br /><br /><br /></p><h4 id=\"github-actions-참고-자료\">github actions 참고 자료</h4><p><a href=\"https://docs.github.com/en/actions\">https://docs.github.com/en/actions</a><br /><a href=\"https://jekyllrb.com/docs/continuous-integration/github-actions/#advantages-of-using-actions\">https://jekyllrb.com/docs/continuous-integration/github-actions/#advantages-of-using-actions</a></p>",
            "url": "https://jheehg.github.io/2022/08/15/deploy-with-github-actions",
            
            
            
            "tags": ["jekyll","github actions"],
            
            "date_published": "2022-08-15T00:00:00+00:00",
            "date_modified": "2022-08-15T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2022/07/31/tutorial-for-gitblog",
            "title": "github blog 생성해보기",
            "summary": "github blog를 생성해보는 과정을 적은 포스트입니다.",
            "content_text": "github blog 생성개발블로그 시작을 그렇게도 망설이고 미뤘는데 이왕이면 블로그 생성, 운영 하면서 겪는 경험도도움이 많이 될 것 같아 얼레벌레 시작하게 된 블로그.욕심 부리지 않고 천천히 배워볼 예정이다. 👏  레파지토리 생성github-pages 배포를 위해 반드시 아래 규칙을 따라 레파지토리를 생성해야 한다.username.github.io      맘에드는 jekyll theme 을 적용하기무료테마를 고른 후, git clone 하여 일단 테마의 모든 내용을 내 깃헙 블로그 레파지토리 디렉토리로 옮기는 것으로 시작한다. 다 옮겼다면 커밋, 푸시를 한다.        1~3분 정도 지나면 커밋된 레파지토리 변경 내용이 github-pages 를 통해 배포가 되어있고, username.github.io 로 들어가서 배포된 사항을 확인할 수 있다.        로컬에서 블로그를 실행하려면 다음과 같은 과정이 필요하다고 한다.jekyll 과 ruby 설치가 필요한데, mac OS 환경의 설치 방법은 다음 doc을 참고하였다.https://jekyllrb-ko.github.io/docs/installation/macos/  로컬설치 참고rbenv 를 통해 ruby 를 설치하면 프로젝트마다 여러 버전을 설치할 수 있다고 하는데성격 급한 나머지 이 내용을 못보고 ruby를 설치해버린 나..근데 ruby 를 평소에 배워본적도 사용해본적도 없는 상태이므로 일단은 나중에 필요하면 설치하도록 하고 다음단계로 넘어갔다.로컬에서 실행해보려고 했는데 여기서 몇 가지 문제점들이 발생했다.  bundler, bundle은 무엇인가? 😂 npm 같은 존재인가..  Gemfile 에 적용된 gem들의 버전이 다 deprecated 된 상태라 도통 실행이 되질 않는다.  2번의 문제를 해결하면 실행은 할 수 있을 것 같은데 오늘 처음 본 bundle, gem…. 하아…^^해결 방법  bundle update --bundler 를 통해 bundler 버전을 업데이트 해주었다.Gemfile에 적용된 버전은 지원하지 않는 버전인데 무슨 버전으로 업데이트 해야할지 몰라서 latest 로 설치했다.  bundle outdated 하면 현재 쓰는 gem 중에서 업데이트 대상에 속하는 gem 들을 알려주는데 뭐가 뭔지도 모르겠고 거의 모든 gem이 outdated 상태여서 모든 gem을 다 업데이트 해주기로 했다.  bundle update --all 로 outdated 된 gem을 모두 업데이트 해준다.  1~3번까지 모두 했는데도 또 오류가 난다. ^^  오류 로그를 보니 webrick 파일을 로드할 수 없다는 내용이었다. 음….   구글링을 해보면 webbrick 또한 설치를 해주면 된다고 하니, bundle add webrick 로 설치를 진행한다.🔗 webrick이란? https://github.com/ruby/webrick   bundle exec jekyll serve 로 서버를 실행한 후 localhost:4000 으로 접속하면 로컬 실행이 마무리 된다.이제 하나하나 커스텀하는 과정은 아래 리소스를 참고해서 진행할 예정이다.https://jekyllrb-ko.github.io https://bundler.io",
            "content_html": "<h3 id=\"github-blog-생성\">github blog 생성</h3><p>개발블로그 시작을 그렇게도 망설이고 미뤘는데 이왕이면 블로그 생성, 운영 하면서 겪는 경험도도움이 많이 될 것 같아 얼레벌레 시작하게 된 블로그.<br />욕심 부리지 않고 천천히 배워볼 예정이다. 👏<br /><br /></p><ul>  <li>레파지토리 생성<br /><code class=\"language-plaintext highlighter-rouge\">github-pages</code> 배포를 위해 반드시 아래 규칙을 따라 레파지토리를 생성해야 한다.</li></ul><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>username.github.io</code></pre></div></div><ul>  <li>    <p>맘에드는 <code class=\"language-plaintext highlighter-rouge\">jekyll theme</code> 을 적용하기<br />무료테마를 고른 후, <code class=\"language-plaintext highlighter-rouge\">git clone</code> 하여 일단 테마의 모든 내용을 내 깃헙 블로그 레파지토리 디렉토리로 옮기는 것으로 시작한다. 다 옮겼다면 커밋, 푸시를 한다.</p>  </li>  <li>    <p>1~3분 정도 지나면 커밋된 레파지토리 변경 내용이 <code class=\"language-plaintext highlighter-rouge\">github-pages</code> 를 통해 배포가 되어있고, <code class=\"language-plaintext highlighter-rouge\">username.github.io</code> 로 들어가서 배포된 사항을 확인할 수 있다.</p>  </li>  <li>    <p>로컬에서 블로그를 실행하려면 다음과 같은 과정이 필요하다고 한다.<br /><code class=\"language-plaintext highlighter-rouge\">jekyll</code> 과 <code class=\"language-plaintext highlighter-rouge\">ruby</code> 설치가 필요한데, mac OS 환경의 설치 방법은 다음 doc을 참고하였다.<br /><a href=\"https://jekyllrb-ko.github.io/docs/installation/macos/\">https://jekyllrb-ko.github.io/docs/installation/macos/</a></p>  </li></ul><p><br /></p><h3 id=\"로컬설치-참고\">로컬설치 참고</h3><p><code class=\"language-plaintext highlighter-rouge\">rbenv</code> 를 통해 <code class=\"language-plaintext highlighter-rouge\">ruby</code> 를 설치하면 프로젝트마다 여러 버전을 설치할 수 있다고 하는데<br />성격 급한 나머지 이 내용을 못보고 <code class=\"language-plaintext highlighter-rouge\">ruby</code>를 설치해버린 나..<br />근데 <code class=\"language-plaintext highlighter-rouge\">ruby</code> 를 평소에 배워본적도 사용해본적도 없는 상태이므로 일단은 나중에 필요하면 설치하도록 하고 다음단계로 넘어갔다.<br /><br /></p><p>로컬에서 실행해보려고 했는데 여기서 몇 가지 문제점들이 발생했다.<br /><br /></p><ol>  <li>bundler, bundle은 무엇인가? 😂 npm 같은 존재인가..</li>  <li>Gemfile 에 적용된 gem들의 버전이 다 deprecated 된 상태라 도통 실행이 되질 않는다.</li>  <li>2번의 문제를 해결하면 실행은 할 수 있을 것 같은데 오늘 처음 본 bundle, gem…. 하아…^^</li></ol><p><br />해결 방법<br /></p><ol>  <li><code class=\"language-plaintext highlighter-rouge\">bundle update --bundler</code> 를 통해 bundler 버전을 업데이트 해주었다.<br />Gemfile에 적용된 버전은 지원하지 않는 버전인데 무슨 버전으로 업데이트 해야할지 몰라서 latest 로 설치했다.<br /><br /></li>  <li><code class=\"language-plaintext highlighter-rouge\">bundle outdated</code> 하면 현재 쓰는 gem 중에서 업데이트 대상에 속하는 gem 들을 알려주는데 뭐가 뭔지도 모르겠고 거의 모든 gem이 outdated 상태여서 모든 gem을 다 업데이트 해주기로 했다.<br /><br /></li>  <li><code class=\"language-plaintext highlighter-rouge\">bundle update --all</code> 로 outdated 된 gem을 모두 업데이트 해준다.<br /><br /></li>  <li>1~3번까지 모두 했는데도 또 오류가 난다. ^^<br /><br /></li>  <li>오류 로그를 보니 webrick 파일을 로드할 수 없다는 내용이었다. 음….<br /><br /><img width=\"720\" alt=\"webbrick-cannot-load-error\" src=\"https://user-images.githubusercontent.com/56527636/182014515-7acd4add-9b23-4760-ae63-6a2f49ca22b4.png\" /> <br /><br /></li>  <li>구글링을 해보면 <code class=\"language-plaintext highlighter-rouge\">webbrick</code> 또한 설치를 해주면 된다고 하니, <code class=\"language-plaintext highlighter-rouge\">bundle add webrick</code> 로 설치를 진행한다.<br />🔗 webrick이란? <a href=\"https://github.com/ruby/webrick\">https://github.com/ruby/webrick</a> <br /><br /></li>  <li><code class=\"language-plaintext highlighter-rouge\">bundle exec jekyll serve</code> 로 서버를 실행한 후 <code class=\"language-plaintext highlighter-rouge\">localhost:4000</code> 으로 접속하면 로컬 실행이 마무리 된다.<br /><img width=\"720\" alt=\"jekyll-serve\" src=\"https://user-images.githubusercontent.com/56527636/182014485-6e044f84-3e46-4832-ace4-7cd1565b8955.png\" /></li></ol><p><br /><br /></p><p>이제 하나하나 커스텀하는 과정은 아래 리소스를 참고해서 진행할 예정이다.<br /><a href=\"https://jekyllrb-ko.github.io\">https://jekyllrb-ko.github.io</a> <br /><a href=\"https://bundler.io\">https://bundler.io</a></p>",
            "url": "https://jheehg.github.io/2022/07/31/tutorial-for-gitblog",
            
            
            
            "tags": ["jekyll","gitblog","ruby","bundle"],
            
            "date_published": "2022-07-31T00:00:00+00:00",
            "date_modified": "2022-07-31T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "https://jheehg.github.io/2022/07/31/test",
            "title": "blog post 테스트 글입니다.",
            "summary": "blog post 테스트 글입니다.",
            "content_text": "테스트입니다.test2",
            "content_html": "<p>테스트입니다.test2</p>",
            "url": "https://jheehg.github.io/2022/07/31/test",
            
            
            
            "tags": ["jekyll","coding"],
            
            "date_published": "2022-07-31T00:00:00+00:00",
            "date_modified": "2022-07-31T00:00:00+00:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}